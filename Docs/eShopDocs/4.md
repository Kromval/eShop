# Authentication and Authorization System

  

## Introduction

  

This section covers the implementation of the authentication and authorization system for our online store application. We'll use JWT (JSON Web Tokens) for authentication and implement role-based authorization to control access to different parts of the application based on user roles (User, Manager, Admin).

  

## JWT Authentication Implementation

  

JSON Web Tokens (JWT) provide a secure way to transmit information between parties as a JSON object. We'll use JWTs to authenticate users and maintain their session state.

  

### JWT Service Implementation

  

First, let's implement the JWT service that will generate and validate tokens:

  

```csharp

// OnlineStore.Infrastructure/Services/JwtService.cs

using System;

using System.Collections.Generic;

using System.IdentityModel.Tokens.Jwt;

using System.Security.Claims;

using System.Text;

using Microsoft.Extensions.Configuration;

using Microsoft.IdentityModel.Tokens;

using OnlineStore.Core.Entities;

  

namespace OnlineStore.Infrastructure.Services

{

    public class JwtService

    {

        private readonly IConfiguration _configuration;

        private readonly SymmetricSecurityKey _key;

        public JwtService(IConfiguration configuration)

        {

            _configuration = configuration;

            _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));

        }

        public string GenerateToken(User user)

        {

            var claims = new List<Claim>

            {

                new Claim(JwtRegisteredClaimNames.Sub, user.Username),

                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),

                new Claim(JwtRegisteredClaimNames.Email, user.Email),

                new Claim("UserId", user.Id.ToString()),

                new Claim(ClaimTypes.Role, user.Role)

            };

            var creds = new SigningCredentials(_key, SecurityAlgorithms.HmacSha256);

            var expiry = DateTime.UtcNow.AddMinutes(Convert.ToDouble(_configuration["Jwt:DurationInMinutes"]));

            var token = new JwtSecurityToken(

                issuer: _configuration["Jwt:Issuer"],

                audience: _configuration["Jwt:Audience"],

                claims: claims,

                expires: expiry,

                signingCredentials: creds

            );

            return new JwtSecurityTokenHandler().WriteToken(token);

        }

    }

}

```

  

### Authentication Service Implementation

  

Now, let's implement the authentication service that will handle user registration and login:

  

```csharp

// OnlineStore.Infrastructure/Services/AuthService.cs

using System;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using AutoMapper;
using Microsoft.AspNetCore.Identity;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.Infrastructure.Services
{
    public class AuthService : IAuthService
    {
        private readonly IUserRepository _userRepository;
        private readonly IMapper _mapper;
        private readonly JwtService _jwtService;
        public AuthService(
            IUserRepository userRepository,
            IMapper mapper,
            JwtService jwtService)
        {
            _userRepository = userRepository;
            _mapper = mapper;
            _jwtService = jwtService;
        }

        public async Task<UserDto> RegisterAsync(RegisterDto registerDto)
        {
            // Check if username already exists
            var existingUserByUsername = await _userRepository.GetUserByUsernameAsync(registerDto.Username);

            if (existingUserByUsername != null)

            {

                throw new Exception("Username is already taken");

            }

            // Check if email already exists

            var existingUserByEmail = await _userRepository.GetUserByEmailAsync(registerDto.Email);

            if (existingUserByEmail != null)

            {

                throw new Exception("Email is already registered");

            }

            // Check if passwords match

            if (registerDto.Password != registerDto.ConfirmPassword)

            {

                throw new Exception("Passwords do not match");

            }

            // Create new user

            var user = _mapper.Map<User>(registerDto);

            user.PasswordHash = HashPassword(registerDto.Password);

            user.Role = "User"; // Default role for new registrations

            user.CreatedAt = DateTime.UtcNow;

            // Save user to database

            await _userRepository.AddAsync(user);

            // Return user DTO

            return _mapper.Map<UserDto>(user);

        }

        public async Task<string> LoginAsync(LoginDto loginDto)

        {

            // Get user by username

            var user = await _userRepository.GetUserByUsernameAsync(loginDto.Username);

            if (user == null)

            {

                throw new Exception("Invalid username or password");

            }

            // Verify password

            if (!VerifyPasswordHash(loginDto.Password, user.PasswordHash))

            {

                throw new Exception("Invalid username or password");

            }

            // Generate JWT token

            return _jwtService.GenerateToken(user);

        }

        public async Task<UserDto> GetCurrentUserAsync(string username)

        {

            var user = await _userRepository.GetUserByUsernameAsync(username);

            if (user == null)

            {

                throw new Exception("User not found");

            }

            return _mapper.Map<UserDto>(user);

        }

        private string HashPassword(string password)

        {

            using (var hmac = new HMACSHA512())

            {

                var salt = hmac.Key;

                var hash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password));

                // Combine salt and hash

                var hashBytes = new byte[salt.Length + hash.Length];

                Array.Copy(salt, 0, hashBytes, 0, salt.Length);

                Array.Copy(hash, 0, hashBytes, salt.Length, hash.Length);

                return Convert.ToBase64String(hashBytes);

            }

        }

        private bool VerifyPasswordHash(string password, string storedHash)

        {

            var hashBytes = Convert.FromBase64String(storedHash);

            // Extract salt (first 64 bytes)

            var salt = new byte[64];

            Array.Copy(hashBytes, 0, salt, 0, 64);

            // Compute hash with the same salt

            using (var hmac = new HMACSHA512(salt))

            {

                var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password));

                // Compare computed hash with stored hash

                for (int i = 0; i < computedHash.Length; i++)

                {

                    if (computedHash[i] != hashBytes[i + 64])

                    {

                        return false;

                    }

                }

                return true;

            }

        }

    }

}

```

  

### User Repository Implementation

  

Let's implement the user repository to handle user data access:

  

```csharp

// OnlineStore.Infrastructure/Repositories/UserRepository.cs

using System;

using System.Collections.Generic;

using System.Linq;

using System.Threading.Tasks;

using Microsoft.EntityFrameworkCore;

using OnlineStore.Core.Entities;

using OnlineStore.Core.Interfaces;

using OnlineStore.Infrastructure.Data;

  

namespace OnlineStore.Infrastructure.Repositories

{

    public class UserRepository : Repository<User>, IUserRepository

    {

        public UserRepository(ApplicationDbContext context) : base(context)

        {

        }

        public async Task<User> GetUserByUsernameAsync(string username)

        {

            return await _context.Users

                .FirstOrDefaultAsync(u => u.Username.ToLower() == username.ToLower());

        }

        public async Task<User> GetUserByEmailAsync(string email)

        {

            return await _context.Users

                .FirstOrDefaultAsync(u => u.Email.ToLower() == email.ToLower());

        }

        public async Task<IReadOnlyList<User>> GetUsersByRoleAsync(string role)

        {

            return await _context.Users

                .Where(u => u.Role == role)

                .ToListAsync();

        }

    }

}

```

  

### User Service Implementation

  

Now, let's implement the user service for managing users:

  

```csharp

// OnlineStore.Infrastructure/Services/UserService.cs

using System;

using System.Collections.Generic;

using System.Threading.Tasks;

using AutoMapper;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.Infrastructure.Services

{

    public class UserService : IUserService

    {

        private readonly IUserRepository _userRepository;

        private readonly IMapper _mapper;

        public UserService(IUserRepository userRepository, IMapper mapper)

        {

            _userRepository = userRepository;

            _mapper = mapper;

        }

        public async Task<UserDto> GetUserByIdAsync(Guid id)

        {

            var user = await _userRepository.GetByIdAsync(id);

            if (user == null)

            {

                throw new Exception($"User with ID {id} not found");

            }

            return _mapper.Map<UserDto>(user);

        }

        public async Task<List<UserDto>> GetAllUsersAsync()

        {

            var users = await _userRepository.ListAllAsync();

            return _mapper.Map<List<UserDto>>(users);

        }

        public async Task<List<UserDto>> GetUsersByRoleAsync(string role)

        {

            var users = await _userRepository.GetUsersByRoleAsync(role);

            return _mapper.Map<List<UserDto>>(users);

        }

        public async Task<UserDto> UpdateUserRoleAsync(Guid id, string role)

        {

            // Validate role

            if (role != "User" && role != "Manager" && role != "Admin")

            {

                throw new Exception("Invalid role. Role must be User, Manager, or Admin");

            }

            var user = await _userRepository.GetByIdAsync(id);

            if (user == null)

            {

                throw new Exception($"User with ID {id} not found");

            }

            user.Role = role;

            user.UpdatedAt = DateTime.UtcNow;

            await _userRepository.UpdateAsync(user);

            return _mapper.Map<UserDto>(user);

        }

        public async Task DeleteUserAsync(Guid id)

        {

            var user = await _userRepository.GetByIdAsync(id);

            if (user == null)

            {

                throw new Exception($"User with ID {id} not found");

            }

            await _userRepository.DeleteAsync(user);

        }

    }

}

```

  

## Role-Based Authorization

  

Now, let's implement role-based authorization to control access to different parts of the application based on user roles.

  

### Authorization Requirements

  

We'll define three user roles with different permissions:

  

1. **User**:

   - Can search and view products

   - Can add products to cart

   - Can place orders

   - Can view their own order history

   - Can update their profile

  

2. **Manager**:

   - All User permissions

   - Can add, edit, and update product information

   - Can manage product categories

   - Can view and update order statuses

   - Can access sales and product statistics

  

3. **Admin**:

   - All Manager permissions

   - Can manage users (create, edit, delete)

   - Can assign user roles

  

### JWT Configuration in Program.cs

  

Let's update the Program.cs file to configure JWT authentication and authorization:

  

```csharp

// OnlineStore.API/Program.cs (updated)

using System.Text;

using Microsoft.AspNetCore.Authentication.JwtBearer;

using Microsoft.EntityFrameworkCore;

using Microsoft.IdentityModel.Tokens;

using Microsoft.OpenApi.Models;

using OnlineStore.Core.Interfaces;

using OnlineStore.Infrastructure.Data;

using OnlineStore.Infrastructure.Mapping;

using OnlineStore.Infrastructure.Repositories;

using OnlineStore.Infrastructure.Services;

  

var builder = WebApplication.CreateBuilder(args);

  

// Add services to the container

builder.Services.AddControllers();

  

// Add DbContext

builder.Services.AddDbContext<ApplicationDbContext>(options =>

    options.UseNpgsql(

        builder.Configuration.GetConnectionString("DefaultConnection"),

        npgsqlOptions => npgsqlOptions.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)

    )

);

  

// Add AutoMapper

builder.Services.AddAutoMapper(typeof(MappingProfile));

  

// Add repositories

builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

builder.Services.AddScoped<IProductRepository, ProductRepository>();

builder.Services.AddScoped<IUserRepository, UserRepository>();

builder.Services.AddScoped<ICategoryRepository, CategoryRepository>();

builder.Services.AddScoped<IOrderRepository, OrderRepository>();

builder.Services.AddScoped<IShoppingCartRepository, ShoppingCartRepository>();

  

// Add JWT service

builder.Services.AddScoped<JwtService>();

  

// Add services

builder.Services.AddScoped<IAuthService, AuthService>();

builder.Services.AddScoped<IProductService, ProductService>();

builder.Services.AddScoped<ICategoryService, CategoryService>();

builder.Services.AddScoped<IOrderService, OrderService>();

builder.Services.AddScoped<ICartService, CartService>();

builder.Services.AddScoped<IUserService, UserService>();

builder.Services.AddScoped<IStatisticsService, StatisticsService>();

  

// Add JWT Authentication

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)

    .AddJwtBearer(options =>

    {

        options.TokenValidationParameters = new TokenValidationParameters

        {

            ValidateIssuerSigningKey = true,

            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(

                builder.Configuration["Jwt:Key"])),

            ValidateIssuer = true,

            ValidIssuer = builder.Configuration["Jwt:Issuer"],

            ValidateAudience = true,

            ValidAudience = builder.Configuration["Jwt:Audience"],

            ValidateLifetime = true,

            ClockSkew = TimeSpan.Zero

        };

    });

  

// Add Authorization Policies

builder.Services.AddAuthorization(options =>

{

    options.AddPolicy("RequireUserRole", policy => policy.RequireRole("User", "Manager", "Admin"));

    options.AddPolicy("RequireManagerRole", policy => policy.RequireRole("Manager", "Admin"));

    options.AddPolicy("RequireAdminRole", policy => policy.RequireRole("Admin"));

});

  

// Add Swagger

builder.Services.AddEndpointsApiExplorer();

builder.Services.AddSwaggerGen(c =>

{

    c.SwaggerDoc("v1", new OpenApiInfo { Title = "OnlineStore API", Version = "v1" });

    // Add JWT Authentication to Swagger

    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme

    {

        Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",

        Name = "Authorization",

        In = ParameterLocation.Header,

        Type = SecuritySchemeType.ApiKey,

        Scheme = "Bearer"

    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement

    {

        {

            new OpenApiSecurityScheme

            {

                Reference = new OpenApiReference

                {

                    Type = ReferenceType.SecurityScheme,

                    Id = "Bearer"

                }

            },

            new string[] { }

        }

    });

});

  

// Add CORS

builder.Services.AddCors(options =>

{

    options.AddPolicy("AllowAll", builder =>

        builder.AllowAnyOrigin()

               .AllowAnyMethod()

               .AllowAnyHeader());

});

  

var app = builder.Build();

  

// Configure the HTTP request pipeline

if (app.Environment.IsDevelopment())

{

    app.UseSwagger();

    app.UseSwaggerUI();

    app.UseDeveloperExceptionPage();

}

else

{

    app.UseExceptionHandler("/error");

    app.UseHsts();

}

  

app.UseHttpsRedirection();

app.UseStaticFiles();

app.UseRouting();

app.UseCors("AllowAll");

  

app.UseAuthentication();

app.UseAuthorization();

  

app.MapControllers();

  

// Apply migrations and seed data in development

if (app.Environment.IsDevelopment())

{

    using (var scope = app.Services.CreateScope())

    {

        var services = scope.ServiceProvider;

        try

        {

            var context = services.GetRequiredService<ApplicationDbContext>();

            context.Database.Migrate();

            // Seed data

            // var seeder = services.GetRequiredService<DbSeeder>();

            // await seeder.SeedAsync();

        }

        catch (Exception ex)

        {

            var logger = services.GetRequiredService<ILogger<Program>>();

            logger.LogError(ex, "An error occurred during migration");

        }

    }

}

  

app.Run();

```

  

### Updating Controllers with Authorization Attributes

  

Let's update our controllers to use the authorization policies:

  

```csharp

// OnlineStore.API/Controllers/ProductsController.cs (updated)

using System;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Mvc;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Controllers

{

    [ApiController]

    [Route("api/[controller]")]

    public class ProductsController : ControllerBase

    {

        private readonly IProductService _productService;

        public ProductsController(IProductService productService)

        {

            _productService = productService;

        }

        [HttpGet]

        public async Task<ActionResult<PaginatedResponse<ProductDto>>> GetProducts(

            [FromQuery] int page = 1,

            [FromQuery] int pageSize = 10)

        {

            var products = await _productService.GetProductsAsync(page, pageSize);

            return Ok(products);

        }

        [HttpGet("{id}")]

        public async Task<ActionResult<ProductDto>> GetProduct(Guid id)

        {

            var product = await _productService.GetProductByIdAsync(id);

            if (product == null)

            {

                return NotFound();

            }

            return Ok(product);

        }

        [HttpGet("search")]

        public async Task<ActionResult<PaginatedResponse<ProductDto>>> SearchProducts([FromQuery] SearchDto searchDto)

        {

            var products = await _productService.SearchProductsAsync(searchDto);

            return Ok(products);

        }

        [HttpGet("category/{categoryId}")]

        public async Task<ActionResult<PaginatedResponse<ProductDto>>> GetProductsByCategory(

            Guid categoryId,

            [FromQuery] int page = 1,

            [FromQuery] int pageSize = 10)

        {

            var products = await _productService.GetProductsByCategoryAsync(categoryId, page, pageSize);

            return Ok(products);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpPost]

        public async Task<ActionResult<ProductDto>> CreateProduct([FromForm] ProductCreateDto productDto)

        {

            var product = await _productService.CreateProductAsync(productDto);

            return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpPut("{id}")]

        public async Task<ActionResult<ProductDto>> UpdateProduct(Guid id, ProductUpdateDto productDto)

        {

            try

            {

                var product = await _productService.UpdateProductAsync(id, productDto);

                return Ok(product);

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpDelete("{id}")]

        public async Task<ActionResult> DeleteProduct(Guid id)

        {

            try

            {

                await _productService.DeleteProductAsync(id);

                return NoContent();

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

    }

}

  

// OnlineStore.API/Controllers/CategoriesController.cs (updated)

using System;

using System.Collections.Generic;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Mvc;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Controllers

{

    [ApiController]

    [Route("api/[controller]")]

    public class CategoriesController : ControllerBase

    {

        private readonly ICategoryService _categoryService;

        public CategoriesController(ICategoryService categoryService)

        {

            _categoryService = categoryService;

        }

        [HttpGet]

        public async Task<ActionResult<List<CategoryDto>>> GetCategories()

        {

            var categories = await _categoryService.GetAllCategoriesAsync();

            return Ok(categories);

        }

        [HttpGet("with-subcategories")]

        public async Task<ActionResult<List<CategoryDto>>> GetCategoriesWithSubcategories()

        {

            var categories = await _categoryService.GetCategoriesWithSubcategoriesAsync();

            return Ok(categories);

        }

        [HttpGet("{id}")]

        public async Task<ActionResult<CategoryDto>> GetCategory(Guid id)

        {

            var category = await _categoryService.GetCategoryByIdAsync(id);

            if (category == null)

            {

                return NotFound();

            }

            return Ok(category);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpPost]

        public async Task<ActionResult<CategoryDto>> CreateCategory(CategoryCreateDto categoryDto)

        {

            var category = await _categoryService.CreateCategoryAsync(categoryDto);

            return CreatedAtAction(nameof(GetCategory), new { id = category.Id }, category);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpPut("{id}")]

        public async Task<ActionResult<CategoryDto>> UpdateCategory(Guid id, CategoryCreateDto categoryDto)

        {

            try

            {

                var category = await _categoryService.UpdateCategoryAsync(id, categoryDto);

                return Ok(category);

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpDelete("{id}")]

        public async Task<ActionResult> DeleteCategory(Guid id)

        {

            try

            {

                await _categoryService.DeleteCategoryAsync(id);

                return NoContent();

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

    }

}

  

// OnlineStore.API/Controllers/OrdersController.cs (updated)

using System;

using System.Collections.Generic;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Mvc;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Controllers

{

    [ApiController]

    [Route("api/[controller]")]

    [Authorize(Policy = "RequireUserRole")]

    public class OrdersController : ControllerBase

    {

        private readonly IOrderService _orderService;

        public OrdersController(IOrderService orderService)

        {

            _orderService = orderService;

        }

        [HttpGet]

        public async Task<ActionResult<List<OrderDto>>> GetUserOrders()

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var orders = await _orderService.GetOrdersByUserIdAsync(userId);

            return Ok(orders);

        }

        [HttpGet("{id}")]

        public async Task<ActionResult<OrderDto>> GetOrder(Guid id)

        {

            var order = await _orderService.GetOrderByIdAsync(id);

            if (order == null)

            {

                return NotFound();

            }

            // Check if the order belongs to the current user or if the user is a manager/admin

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var userRole = User.FindFirst(System.Security.Claims.ClaimTypes.Role)?.Value;

            if (order.UserId != userId && userRole != "Manager" && userRole != "Admin")

            {

                return Forbid();

            }

            return Ok(order);

        }

        [HttpPost]

        public async Task<ActionResult<OrderDto>> CreateOrder(OrderCreateDto orderDto)

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var order = await _orderService.CreateOrderAsync(userId, orderDto);

            return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpGet("all")]

        public async Task<ActionResult<PaginatedResponse<OrderDto>>> GetAllOrders(

            [FromQuery] int page = 1,

            [FromQuery] int pageSize = 10)

        {

            var orders = await _orderService.GetAllOrdersAsync(page, pageSize);

            return Ok(orders);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpGet("status/{status}")]

        public async Task<ActionResult<PaginatedResponse<OrderDto>>> GetOrdersByStatus(

            string status,

            [FromQuery] int page = 1,

            [FromQuery] int pageSize = 10)

        {

            var orders = await _orderService.GetOrdersByStatusAsync(status, page, pageSize);

            return Ok(orders);

        }

        [Authorize(Policy = "RequireManagerRole")]

        [HttpPut("{id}/status")]

        public async Task<ActionResult<OrderDto>> UpdateOrderStatus(Guid id, OrderStatusUpdateDto statusDto)

        {

            try

            {

                var order = await _orderService.UpdateOrderStatusAsync(id, statusDto);

                return Ok(order);

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

    }

}

  

// OnlineStore.API/Controllers/CartController.cs (updated)

using System;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Mvc;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Controllers

{

    [ApiController]

    [Route("api/[controller]")]

    [Authorize(Policy = "RequireUserRole")]

    public class CartController : ControllerBase

    {

        private readonly ICartService _cartService;

        public CartController(ICartService cartService)

        {

            _cartService = cartService;

        }

        [HttpGet]

        public async Task<ActionResult<CartDto>> GetCart()

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var cart = await _cartService.GetCartAsync(userId);

            return Ok(cart);

        }

        [HttpPost("items")]

        public async Task<ActionResult<CartDto>> AddItemToCart(CartItemCreateDto itemDto)

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var cart = await _cartService.AddItemToCartAsync(userId, itemDto);

            return Ok(cart);

        }

        [HttpPut("items/{itemId}")]

        public async Task<ActionResult<CartDto>> UpdateCartItem(Guid itemId, CartItemUpdateDto itemDto)

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var cart = await _cartService.UpdateCartItemAsync(userId, itemId, itemDto);

            return Ok(cart);

        }

        [HttpDelete("items/{itemId}")]

        public async Task<ActionResult<CartDto>> RemoveCartItem(Guid itemId)

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            var cart = await _cartService.RemoveCartItemAsync(userId, itemId);

            return Ok(cart);

        }

        [HttpDelete("clear")]

        public async Task<ActionResult> ClearCart()

        {

            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);

            await _cartService.ClearCartAsync(userId);

            return NoContent();

        }

    }

}

  

// OnlineStore.API/Controllers/UsersController.cs (updated)

using System;

using System.Collections.Generic;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Mvc;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Controllers

{

    [ApiController]

    [Route("api/[controller]")]

    [Authorize(Policy = "RequireAdminRole")]

    public class UsersController : ControllerBase

    {

        private readonly IUserService _userService;

        public UsersController(IUserService userService)

        {

            _userService = userService;

        }

        [HttpGet]

        public async Task<ActionResult<List<UserDto>>> GetUsers()

        {

            var users = await _userService.GetAllUsersAsync();

            return Ok(users);

        }

        [HttpGet("{id}")]

        public async Task<ActionResult<UserDto>> GetUser(Guid id)

        {

            var user = await _userService.GetUserByIdAsync(id);

            if (user == null)

            {

                return NotFound();

            }

            return Ok(user);

        }

        [HttpGet("role/{role}")]

        public async Task<ActionResult<List<UserDto>>> GetUsersByRole(string role)

        {

            var users = await _userService.GetUsersByRoleAsync(role);

            return Ok(users);

        }

        [HttpPut("{id}/role")]

        public async Task<ActionResult<UserDto>> UpdateUserRole(Guid id, [FromBody] string role)

        {

            try

            {

                var user = await _userService.UpdateUserRoleAsync(id, role);

                return Ok(user);

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

        [HttpDelete("{id}")]

        public async Task<ActionResult> DeleteUser(Guid id)

        {

            try

            {

                await _userService.DeleteUserAsync(id);

                return NoContent();

            }

            catch (Exception ex)

            {

                return NotFound(ex.Message);

            }

        }

    }

}

  

// OnlineStore.API/Controllers/StatisticsController.cs (updated)

using System;

using System.Collections.Generic;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;

using Microsoft.AspNetCore.Mvc;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Controllers

{

    [ApiController]

    [Route("api/[controller]")]

    [Authorize(Policy = "RequireManagerRole")]

    public class StatisticsController : ControllerBase

    {

        private readonly IStatisticsService _statisticsService;

        public StatisticsController(IStatisticsService statisticsService)

        {

            _statisticsService = statisticsService;

        }

        [HttpGet("orders-by-status")]

        public async Task<ActionResult<Dictionary<string, int>>> GetOrdersCountByStatus()

        {

            var statistics = await _statisticsService.GetOrdersCountByStatusAsync();

            return Ok(statistics);

        }

        [HttpGet("sales")]

        public async Task<ActionResult<Dictionary<string, decimal>>> GetSalesByTimeRange(

            [FromQuery] DateTime startDate,

            [FromQuery] DateTime endDate,

            [FromQuery] string groupBy = "day")

        {

            var statistics = await _statisticsService.GetSalesByTimeRangeAsync(startDate, endDate, groupBy);

            return Ok(statistics);

        }

        [HttpGet("top-selling-products")]

        public async Task<ActionResult<List<KeyValuePair<string, int>>>> GetTopSellingProducts([FromQuery] int count = 5)

        {

            var statistics = await _statisticsService.GetTopSellingProductsAsync(count);

            return Ok(statistics);

        }

        [HttpGet("sales-by-category")]

        public async Task<ActionResult<Dictionary<string, decimal>>> GetSalesByCategory()

        {

            var statistics = await _statisticsService.GetSalesByCategoryAsync();

            return Ok(statistics);

        }

    }

}

```

  

## Authentication Middleware

  

Let's create a custom authentication middleware to handle JWT token validation and user claims:

  

```csharp

// OnlineStore.API/Middleware/JwtMiddleware.cs

using System;

using System.IdentityModel.Tokens.Jwt;

using System.Linq;

using System.Text;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Http;

using Microsoft.Extensions.Configuration;

using Microsoft.IdentityModel.Tokens;

using OnlineStore.Core.Interfaces;

  

namespace OnlineStore.API.Middleware

{

    public class JwtMiddleware

    {

        private readonly RequestDelegate _next;

        private readonly IConfiguration _configuration;

        public JwtMiddleware(RequestDelegate next, IConfiguration configuration)

        {

            _next = next;

            _configuration = configuration;

        }

        public async Task InvokeAsync(HttpContext context, IUserRepository userRepository)

        {

            var token = context.Request.Headers["Authorization"].FirstOrDefault()?.Split(" ").Last();

            if (token != null)

            {

                await AttachUserToContextAsync(context, userRepository, token);

            }

            await _next(context);

        }

        private async Task AttachUserToContextAsync(HttpContext context, IUserRepository userRepository, string token)

        {

            try

            {

                var tokenHandler = new JwtSecurityTokenHandler();

                var key = Encoding.ASCII.GetBytes(_configuration["Jwt:Key"]);

                tokenHandler.ValidateToken(token, new TokenValidationParameters

                {

                    ValidateIssuerSigningKey = true,

                    IssuerSigningKey = new SymmetricSecurityKey(key),

                    ValidateIssuer = true,

                    ValidIssuer = _configuration["Jwt:Issuer"],

                    ValidateAudience = true,

                    ValidAudience = _configuration["Jwt:Audience"],

                    ValidateLifetime = true,

                    ClockSkew = TimeSpan.Zero

                }, out var validatedToken);

                var jwtToken = (JwtSecurityToken)validatedToken;

                var username = jwtToken.Claims.First(x => x.Type == JwtRegisteredClaimNames.Sub).Value;

                // Attach user to context

                var user = await userRepository.GetUserByUsernameAsync(username);

                if (user != null)

                {

                    context.Items["User"] = user;

                }

            }

            catch

            {

                // Do nothing if token validation fails

                // User is not attached to context so the request won't have access to secured endpoints

            }

        }

    }

}

```

  

## Error Handling Middleware

  

Let's create a global error handling middleware to handle exceptions:

  

```csharp

// OnlineStore.API/Middleware/ErrorHandlingMiddleware.cs

using System;

using System.Net;

using System.Text.Json;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Http;

using Microsoft.Extensions.Logging;

  

namespace OnlineStore.API.Middleware

{

    public class ErrorHandlingMiddleware

    {

        private readonly RequestDelegate _next;

        private readonly ILogger<ErrorHandlingMiddleware> _logger;

        public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)

        {

            _next = next;

            _logger = logger;

        }

        public async Task InvokeAsync(HttpContext context)

        {

            try

            {

                await _next(context);

            }

            catch (Exception ex)

            {

                await HandleExceptionAsync(context, ex);

            }

        }

        private Task HandleExceptionAsync(HttpContext context, Exception exception)

        {

            _logger.LogError(exception, "An unhandled exception occurred");

            var code = HttpStatusCode.InternalServerError; // 500 if unexpected

            // Customize status code based on exception type

            if (exception is UnauthorizedAccessException)

            {

                code = HttpStatusCode.Unauthorized; // 401

            }

            else if (exception is ArgumentException || exception is FormatException)

            {

                code = HttpStatusCode.BadRequest; // 400

            }

            else if (exception.Message.Contains("not found", StringComparison.OrdinalIgnoreCase))

            {

                code = HttpStatusCode.NotFound; // 404

            }

            var result = JsonSerializer.Serialize(new { error = exception.Message });

            context.Response.ContentType = "application/json";

            context.Response.StatusCode = (int)code;

            return context.Response.WriteAsync(result);

        }

    }

}

```

  

## Register Middleware in Program.cs

  

Let's update the Program.cs file to register our custom middleware:

  

```csharp

// OnlineStore.API/Program.cs (updated with middleware)

// ... existing code ...

  

var app = builder.Build();

  

// Configure the HTTP request pipeline

if (app.Environment.IsDevelopment())

{

    app.UseSwagger();

    app.UseSwaggerUI();

    app.UseDeveloperExceptionPage();

}

else

{

    app.UseMiddleware<ErrorHandlingMiddleware>();

    app.UseHsts();

}

  

app.UseHttpsRedirection();

app.UseStaticFiles();

app.UseRouting();

app.UseCors("AllowAll");

  

// Add JWT middleware before authentication

app.UseMiddleware<JwtMiddleware>();

  

app.UseAuthentication();

app.UseAuthorization();

  

app.MapControllers();

  

// ... rest of the code ...

```

  

## Unit Testing Authentication and Authorization

  

Let's create unit tests for our authentication and authorization components:

  

```csharp

// OnlineStore.Tests/AuthServiceTests.cs

using System;

using System.Threading.Tasks;

using AutoMapper;

using Moq;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Entities;

using OnlineStore.Core.Interfaces;

using OnlineStore.Infrastructure.Mapping;

using OnlineStore.Infrastructure.Services;

using Xunit;

  

namespace OnlineStore.Tests

{

    public class AuthServiceTests

    {

        private readonly Mock<IUserRepository> _mockUserRepository;

        private readonly IMapper _mapper;

        private readonly Mock<JwtService> _mockJwtService;

        private readonly AuthService _authService;

        public AuthServiceTests()

        {

            _mockUserRepository = new Mock<IUserRepository>();

            // Configure AutoMapper

            var mapperConfig = new MapperConfiguration(cfg =>

            {

                cfg.AddProfile(new MappingProfile());

            });

            _mapper = mapperConfig.CreateMapper();

            _mockJwtService = new Mock<JwtService>(null);

            _authService = new AuthService(

                _mockUserRepository.Object,

                _mapper,

                _mockJwtService.Object);

        }

        [Fact]

        public async Task RegisterAsync_ShouldCreateNewUser_WhenValidDataProvided()

        {

            // Arrange

            var registerDto = new RegisterDto

            {

                Username = "testuser",

                Email = "test@example.com",

                Password = "Password123!",

                ConfirmPassword = "Password123!"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(registerDto.Username))

                .ReturnsAsync((User)null);

            _mockUserRepository.Setup(repo => repo.GetUserByEmailAsync(registerDto.Email))

                .ReturnsAsync((User)null);

            _mockUserRepository.Setup(repo => repo.AddAsync(It.IsAny<User>()))

                .ReturnsAsync((User user) => user);

            // Act

            var result = await _authService.RegisterAsync(registerDto);

            // Assert

            Assert.NotNull(result);

            Assert.Equal(registerDto.Username, result.Username);

            Assert.Equal(registerDto.Email, result.Email);

            Assert.Equal("User", result.Role);

            _mockUserRepository.Verify(repo => repo.AddAsync(It.IsAny<User>()), Times.Once);

        }

        [Fact]

        public async Task RegisterAsync_ShouldThrowException_WhenUsernameAlreadyExists()

        {

            // Arrange

            var registerDto = new RegisterDto

            {

                Username = "existinguser",

                Email = "test@example.com",

                Password = "Password123!",

                ConfirmPassword = "Password123!"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(registerDto.Username))

                .ReturnsAsync(new User { Username = registerDto.Username });

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _authService.RegisterAsync(registerDto));

            Assert.Equal("Username is already taken", exception.Message);

            _mockUserRepository.Verify(repo => repo.AddAsync(It.IsAny<User>()), Times.Never);

        }

        [Fact]

        public async Task RegisterAsync_ShouldThrowException_WhenEmailAlreadyExists()

        {

            // Arrange

            var registerDto = new RegisterDto

            {

                Username = "testuser",

                Email = "existing@example.com",

                Password = "Password123!",

                ConfirmPassword = "Password123!"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(registerDto.Username))

                .ReturnsAsync((User)null);

            _mockUserRepository.Setup(repo => repo.GetUserByEmailAsync(registerDto.Email))

                .ReturnsAsync(new User { Email = registerDto.Email });

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _authService.RegisterAsync(registerDto));

            Assert.Equal("Email is already registered", exception.Message);

            _mockUserRepository.Verify(repo => repo.AddAsync(It.IsAny<User>()), Times.Never);

        }

        [Fact]

        public async Task RegisterAsync_ShouldThrowException_WhenPasswordsDoNotMatch()

        {

            // Arrange

            var registerDto = new RegisterDto

            {

                Username = "testuser",

                Email = "test@example.com",

                Password = "Password123!",

                ConfirmPassword = "DifferentPassword!"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(registerDto.Username))

                .ReturnsAsync((User)null);

            _mockUserRepository.Setup(repo => repo.GetUserByEmailAsync(registerDto.Email))

                .ReturnsAsync((User)null);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _authService.RegisterAsync(registerDto));

            Assert.Equal("Passwords do not match", exception.Message);

            _mockUserRepository.Verify(repo => repo.AddAsync(It.IsAny<User>()), Times.Never);

        }

        [Fact]

        public async Task LoginAsync_ShouldReturnToken_WhenCredentialsAreValid()

        {

            // Arrange

            var loginDto = new LoginDto

            {

                Username = "testuser",

                Password = "Password123!"

            };

            var user = new User

            {

                Id = Guid.NewGuid(),

                Username = loginDto.Username,

                PasswordHash = HashPassword(loginDto.Password),

                Email = "test@example.com",

                Role = "User"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(loginDto.Username))

                .ReturnsAsync(user);

            _mockJwtService.Setup(service => service.GenerateToken(It.IsAny<User>()))

                .Returns("test-jwt-token");

            // Act

            var result = await _authService.LoginAsync(loginDto);

            // Assert

            Assert.Equal("test-jwt-token", result);

        }

        [Fact]

        public async Task LoginAsync_ShouldThrowException_WhenUserDoesNotExist()

        {

            // Arrange

            var loginDto = new LoginDto

            {

                Username = "nonexistentuser",

                Password = "Password123!"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(loginDto.Username))

                .ReturnsAsync((User)null);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _authService.LoginAsync(loginDto));

            Assert.Equal("Invalid username or password", exception.Message);

        }

        [Fact]

        public async Task LoginAsync_ShouldThrowException_WhenPasswordIsInvalid()

        {

            // Arrange

            var loginDto = new LoginDto

            {

                Username = "testuser",

                Password = "WrongPassword!"

            };

            var user = new User

            {

                Id = Guid.NewGuid(),

                Username = loginDto.Username,

                PasswordHash = HashPassword("Password123!"), // Different password

                Email = "test@example.com",

                Role = "User"

            };

            _mockUserRepository.Setup(repo => repo.GetUserByUsernameAsync(loginDto.Username))

                .ReturnsAsync(user);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _authService.LoginAsync(loginDto));

            Assert.Equal("Invalid username or password", exception.Message);

        }

        // Helper method to hash password for testing

        private string HashPassword(string password)

        {

            using (var hmac = new System.Security.Cryptography.HMACSHA512())

            {

                var salt = hmac.Key;

                var hash = hmac.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));

                // Combine salt and hash

                var hashBytes = new byte[salt.Length + hash.Length];

                Array.Copy(salt, 0, hashBytes, 0, salt.Length);

                Array.Copy(hash, 0, hashBytes, salt.Length, hash.Length);

                return Convert.ToBase64String(hashBytes);

            }

        }

    }

}

  

// OnlineStore.Tests/UserServiceTests.cs

using System;

using System.Collections.Generic;

using System.Threading.Tasks;

using AutoMapper;

using Moq;

using OnlineStore.Core.DTOs;

using OnlineStore.Core.Entities;

using OnlineStore.Core.Interfaces;

using OnlineStore.Infrastructure.Mapping;

using OnlineStore.Infrastructure.Services;

using Xunit;

  

namespace OnlineStore.Tests

{

    public class UserServiceTests

    {

        private readonly Mock<IUserRepository> _mockUserRepository;

        private readonly IMapper _mapper;

        private readonly UserService _userService;

        public UserServiceTests()

        {

            _mockUserRepository = new Mock<IUserRepository>();

            // Configure AutoMapper

            var mapperConfig = new MapperConfiguration(cfg =>

            {

                cfg.AddProfile(new MappingProfile());

            });

            _mapper = mapperConfig.CreateMapper();

            _userService = new UserService(

                _mockUserRepository.Object,

                _mapper);

        }

        [Fact]

        public async Task GetUserByIdAsync_ShouldReturnUser_WhenUserExists()

        {

            // Arrange

            var userId = Guid.NewGuid();

            var user = new User

            {

                Id = userId,

                Username = "testuser",

                Email = "test@example.com",

                Role = "User",

                CreatedAt = DateTime.UtcNow

            };

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync(user);

            // Act

            var result = await _userService.GetUserByIdAsync(userId);

            // Assert

            Assert.NotNull(result);

            Assert.Equal(userId, result.Id);

            Assert.Equal("testuser", result.Username);

            Assert.Equal("test@example.com", result.Email);

            Assert.Equal("User", result.Role);

        }

        [Fact]

        public async Task GetUserByIdAsync_ShouldThrowException_WhenUserDoesNotExist()

        {

            // Arrange

            var userId = Guid.NewGuid();

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync((User)null);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _userService.GetUserByIdAsync(userId));

            Assert.Equal($"User with ID {userId} not found", exception.Message);

        }

        [Fact]

        public async Task GetAllUsersAsync_ShouldReturnAllUsers()

        {

            // Arrange

            var users = new List<User>

            {

                new User

                {

                    Id = Guid.NewGuid(),

                    Username = "user1",

                    Email = "user1@example.com",

                    Role = "User"

                },

                new User

                {

                    Id = Guid.NewGuid(),

                    Username = "user2",

                    Email = "user2@example.com",

                    Role = "Manager"

                }

            };

            _mockUserRepository.Setup(repo => repo.ListAllAsync())

                .ReturnsAsync(users);

            // Act

            var result = await _userService.GetAllUsersAsync();

            // Assert

            Assert.NotNull(result);

            Assert.Equal(2, result.Count);

            Assert.Equal("user1", result[0].Username);

            Assert.Equal("user2", result[1].Username);

        }

        [Fact]

        public async Task GetUsersByRoleAsync_ShouldReturnUsersWithSpecifiedRole()

        {

            // Arrange

            var role = "Manager";

            var users = new List<User>

            {

                new User

                {

                    Id = Guid.NewGuid(),

                    Username = "manager1",

                    Email = "manager1@example.com",

                    Role = role

                },

                new User

                {

                    Id = Guid.NewGuid(),

                    Username = "manager2",

                    Email = "manager2@example.com",

                    Role = role

                }

            };

            _mockUserRepository.Setup(repo => repo.GetUsersByRoleAsync(role))

                .ReturnsAsync(users);

            // Act

            var result = await _userService.GetUsersByRoleAsync(role);

            // Assert

            Assert.NotNull(result);

            Assert.Equal(2, result.Count);

            Assert.Equal("manager1", result[0].Username);

            Assert.Equal("manager2", result[1].Username);

            Assert.All(result, item => Assert.Equal(role, item.Role));

        }

        [Fact]

        public async Task UpdateUserRoleAsync_ShouldUpdateRole_WhenUserExistsAndRoleIsValid()

        {

            // Arrange

            var userId = Guid.NewGuid();

            var user = new User

            {

                Id = userId,

                Username = "testuser",

                Email = "test@example.com",

                Role = "User",

                CreatedAt = DateTime.UtcNow

            };

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync(user);

            _mockUserRepository.Setup(repo => repo.UpdateAsync(It.IsAny<User>()))

                .Returns(Task.CompletedTask);

            // Act

            var result = await _userService.UpdateUserRoleAsync(userId, "Manager");

            // Assert

            Assert.NotNull(result);

            Assert.Equal(userId, result.Id);

            Assert.Equal("Manager", result.Role);

            _mockUserRepository.Verify(repo => repo.UpdateAsync(It.IsAny<User>()), Times.Once);

        }

        [Fact]

        public async Task UpdateUserRoleAsync_ShouldThrowException_WhenUserDoesNotExist()

        {

            // Arrange

            var userId = Guid.NewGuid();

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync((User)null);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _userService.UpdateUserRoleAsync(userId, "Manager"));

            Assert.Equal($"User with ID {userId} not found", exception.Message);

            _mockUserRepository.Verify(repo => repo.UpdateAsync(It.IsAny<User>()), Times.Never);

        }

        [Fact]

        public async Task UpdateUserRoleAsync_ShouldThrowException_WhenRoleIsInvalid()

        {

            // Arrange

            var userId = Guid.NewGuid();

            var user = new User

            {

                Id = userId,

                Username = "testuser",

                Email = "test@example.com",

                Role = "User",

                CreatedAt = DateTime.UtcNow

            };

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync(user);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _userService.UpdateUserRoleAsync(userId, "InvalidRole"));

            Assert.Equal("Invalid role. Role must be User, Manager, or Admin", exception.Message);

            _mockUserRepository.Verify(repo => repo.UpdateAsync(It.IsAny<User>()), Times.Never);

        }

        [Fact]

        public async Task DeleteUserAsync_ShouldDeleteUser_WhenUserExists()

        {

            // Arrange

            var userId = Guid.NewGuid();

            var user = new User

            {

                Id = userId,

                Username = "testuser",

                Email = "test@example.com",

                Role = "User"

            };

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync(user);

            _mockUserRepository.Setup(repo => repo.DeleteAsync(It.IsAny<User>()))

                .Returns(Task.CompletedTask);

            // Act

            await _userService.DeleteUserAsync(userId);

            // Assert

            _mockUserRepository.Verify(repo => repo.DeleteAsync(It.IsAny<User>()), Times.Once);

        }

        [Fact]

        public async Task DeleteUserAsync_ShouldThrowException_WhenUserDoesNotExist()

        {

            // Arrange

            var userId = Guid.NewGuid();

            _mockUserRepository.Setup(repo => repo.GetByIdAsync(userId))

                .ReturnsAsync((User)null);

            // Act & Assert

            var exception = await Assert.ThrowsAsync<Exception>(() => _userService.DeleteUserAsync(userId));

            Assert.Equal($"User with ID {userId} not found", exception.Message);

            _mockUserRepository.Verify(repo => repo.DeleteAsync(It.IsAny<User>()), Times.Never);

        }

    }

}

```

  

## Conclusion

  

In this section, we've implemented a comprehensive authentication and authorization system for our online store application using JWT tokens and role-based access control. The key components include:

  

1. **JWT Authentication**:

   - JWT token generation and validation

   - Secure password hashing

   - User registration and login functionality

  

2. **Role-Based Authorization**:

   - Three user roles: User, Manager, and Admin

   - Authorization policies for each role

   - Controller endpoints secured with appropriate policies

  

3. **Middleware**:

   - JWT middleware for token validation

   - Error handling middleware for global exception handling

  

4. **Unit Tests**:

   - Tests for authentication service

   - Tests for user service

   - Validation of role-based access control

  

This implementation ensures that our application has proper security measures in place and that users can only access the functionality appropriate for their role:

  

- **Users** can browse products, manage their cart, and place orders

- **Managers** can additionally manage products, categories, and order statuses

- **Admins** have full control, including user management

  

In the next section, we'll develop the frontend with React to provide a user interface for interacting with our secured API endpoints.