# Backend Implementation with .NET Web API

## Introduction

This section covers the implementation of the backend API for our online store application using .NET Web API. We'll follow clean architecture principles and implement the repository pattern to ensure separation of concerns and maintainability.

## Setting Up the .NET Web API Project

Let's start by creating a new .NET Web API project with the necessary structure.

### Project Creation

```bash
# Create a new solution
dotnet new sln -n OnlineStore

# Create API project
dotnet new webapi -n OnlineStore.API

# Create Core project for domain models and interfaces
dotnet new classlib -n OnlineStore.Core

# Create Infrastructure project for data access and external services
dotnet new classlib -n OnlineStore.Infrastructure

# Create Tests project
dotnet new xunit -n OnlineStore.Tests

# Add projects to solution
dotnet sln add OnlineStore.API/OnlineStore.API.csproj
dotnet sln add OnlineStore.Core/OnlineStore.Core.csproj
dotnet sln add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj
dotnet sln add OnlineStore.Tests/OnlineStore.Tests.csproj

# Add project references
dotnet add OnlineStore.API/OnlineStore.API.csproj reference OnlineStore.Core/OnlineStore.Core.csproj
dotnet add OnlineStore.API/OnlineStore.API.csproj reference OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj
dotnet add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj reference OnlineStore.Core/OnlineStore.Core.csproj
dotnet add OnlineStore.Tests/OnlineStore.Tests.csproj reference OnlineStore.Core/OnlineStore.Core.csproj
dotnet add OnlineStore.Tests/OnlineStore.Tests.csproj reference OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj
dotnet add OnlineStore.Tests/OnlineStore.Tests.csproj reference OnlineStore.API/OnlineStore.API.csproj
```

### Installing Required Packages

```bash
# Core project packages
dotnet add OnlineStore.Core/OnlineStore.Core.csproj package Microsoft.Extensions.Identity.Stores

# Infrastructure project packages
dotnet add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj package Microsoft.EntityFrameworkCore
dotnet add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj package Microsoft.AspNetCore.Identity.EntityFrameworkCore
dotnet add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj package Microsoft.EntityFrameworkCore.Design

# API project packages
dotnet add OnlineStore.API/OnlineStore.API.csproj package Microsoft.EntityFrameworkCore.Design
dotnet add OnlineStore.API/OnlineStore.API.csproj package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add OnlineStore.API/OnlineStore.API.csproj package Swashbuckle.AspNetCore
dotnet add OnlineStore.API/OnlineStore.API.csproj package AutoMapper.Extensions.Microsoft.DependencyInjection
dotnet add OnlineStore.API/OnlineStore.API.csproj package FluentValidation.AspNetCore

# Test project packages
dotnet add OnlineStore.Tests/OnlineStore.Tests.csproj package Microsoft.EntityFrameworkCore.InMemory
dotnet add OnlineStore.Tests/OnlineStore.Tests.csproj package Moq
dotnet add OnlineStore.Tests/OnlineStore.Tests.csproj package FluentAssertions
```

## Core Project Implementation

Let's start by implementing the Core project, which contains our domain models, interfaces, and DTOs.

### Domain Models

We'll move the entity classes from the previous section to the Core project and refine them.

```csharp
// OnlineStore.Core/Entities/BaseEntity.cs
using System;

namespace OnlineStore.Core.Entities
{
    public abstract class BaseEntity
    {
        public Guid Id { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime? UpdatedAt { get; set; }
    }
}

// OnlineStore.Core/Entities/User.cs
using System;
using System.Collections.Generic;

namespace OnlineStore.Core.Entities
{
    public class User : BaseEntity
    {
        public string Username { get; set; }
        public string Email { get; set; }
        public string PasswordHash { get; set; }
        public string Role { get; set; }
        
        // Navigation properties
        public virtual ICollection<Order> Orders { get; set; }
        public virtual ShoppingCart Cart { get; set; }
    }
}

// OnlineStore.Core/Entities/Category.cs
using System;
using System.Collections.Generic;

namespace OnlineStore.Core.Entities
{
    public class Category : BaseEntity
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public Guid? ParentId { get; set; }
        
        // Navigation properties
        public virtual Category ParentCategory { get; set; }
        public virtual ICollection<Category> Subcategories { get; set; }
        public virtual ICollection<Product> Products { get; set; }
    }
}

// OnlineStore.Core/Entities/Product.cs
using System;
using System.Collections.Generic;
using NpgsqlTypes;

namespace OnlineStore.Core.Entities
{
    public class Product : BaseEntity
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
        public int StockQuantity { get; set; }
        public Guid CategoryId { get; set; }
        public NpgsqlTsVector SearchVector { get; set; }
        
        // Navigation properties
        public virtual Category Category { get; set; }
        public virtual ICollection<ProductImage> Images { get; set; }
        public virtual ICollection<OrderItem> OrderItems { get; set; }
        public virtual ICollection<ProductReview> Reviews { get; set; }
    }
}

// Add similar files for other entities: ProductImage, Order, OrderItem, ShoppingCart, CartItem, ProductReview
```

### Repository Interfaces

Let's define interfaces for our repositories:

```csharp
// OnlineStore.Core/Interfaces/IRepository.cs
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Threading.Tasks;
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces
{
    public interface IRepository<T> where T : BaseEntity
    {
        Task<T> GetByIdAsync(Guid id);
        Task<IReadOnlyList<T>> ListAllAsync();
        Task<IReadOnlyList<T>> ListAsync(Expression<Func<T, bool>> predicate);
        Task<T> AddAsync(T entity);
        Task UpdateAsync(T entity);
        Task DeleteAsync(T entity);
        Task<int> CountAsync(Expression<Func<T, bool>> predicate);
    }
}

// OnlineStore.Core/Interfaces/IProductRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces
{
    public interface IProductRepository : IRepository<Product>
    {
        Task<IReadOnlyList<Product>> SearchProductsAsync(
            string searchTerm, 
            Guid? categoryId = null, 
            decimal? minPrice = null, 
            decimal? maxPrice = null, 
            int page = 1, 
            int pageSize = 10);
            
        Task<int> CountSearchResultsAsync(
            string searchTerm, 
            Guid? categoryId = null, 
            decimal? minPrice = null, 
            decimal? maxPrice = null);
            
        Task<IReadOnlyList<Product>> GetProductsByCategoryAsync(Guid categoryId, int page = 1, int pageSize = 10);
        Task<Product> GetProductWithDetailsAsync(Guid id);
        Task UpdateStockQuantityAsync(Guid id, int quantity);
    }
}

// OnlineStore.Core/Interfaces/IUserRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces
{
    public interface IUserRepository : IRepository<User>
    {
        Task<User> GetUserByUsernameAsync(string username);
        Task<User> GetUserByEmailAsync(string email);
        Task<IReadOnlyList<User>> GetUsersByRoleAsync(string role);
    }
}

// OnlineStore.Core/Interfaces/IOrderRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces
{
    public interface IOrderRepository : IRepository<Order>
    {
        Task<IReadOnlyList<Order>> GetOrdersByUserIdAsync(Guid userId);
        Task<Order> GetOrderWithItemsAsync(Guid orderId);
        Task<IReadOnlyList<Order>> GetOrdersByStatusAsync(string status, int page = 1, int pageSize = 10);
        Task UpdateOrderStatusAsync(Guid orderId, string status);
    }
}

// OnlineStore.Core/Interfaces/ICategoryRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces
{
    public interface ICategoryRepository : IRepository<Category>
    {
        Task<IReadOnlyList<Category>> GetCategoriesWithSubcategoriesAsync();
        Task<Category> GetCategoryWithProductsAsync(Guid categoryId);
    }
}

// OnlineStore.Core/Interfaces/IShoppingCartRepository.cs
using System;
using System.Threading.Tasks;
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces
{
    public interface IShoppingCartRepository : IRepository<ShoppingCart>
    {
        Task<ShoppingCart> GetCartWithItemsAsync(Guid userId);
        Task AddItemToCartAsync(Guid cartId, Guid productId, int quantity);
        Task UpdateCartItemQuantityAsync(Guid cartItemId, int quantity);
        Task RemoveItemFromCartAsync(Guid cartItemId);
        Task ClearCartAsync(Guid cartId);
    }
}
```

### DTOs (Data Transfer Objects)

Let's create DTOs for our API requests and responses:

```csharp
// OnlineStore.Core/DTOs/UserDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class UserDto
    {
        public Guid Id { get; set; }
        public string Username { get; set; }
        public string Email { get; set; }
        public string Role { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}

// OnlineStore.Core/DTOs/RegisterDto.cs
namespace OnlineStore.Core.DTOs
{
    public class RegisterDto
    {
        public string Username { get; set; }
        public string Email { get; set; }
        public string Password { get; set; }
        public string ConfirmPassword { get; set; }
    }
}

// OnlineStore.Core/DTOs/LoginDto.cs
namespace OnlineStore.Core.DTOs
{
    public class LoginDto
    {
        public string Username { get; set; }
        public string Password { get; set; }
    }
}

// OnlineStore.Core/DTOs/ProductDto.cs
using System;
using System.Collections.Generic;

namespace OnlineStore.Core.DTOs
{
    public class ProductDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
        public int StockQuantity { get; set; }
        public Guid CategoryId { get; set; }
        public string CategoryName { get; set; }
        public string MainImageUrl { get; set; }
        public List<string> ImageUrls { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}

// OnlineStore.Core/DTOs/ProductCreateDto.cs
using System;
using Microsoft.AspNetCore.Http;

namespace OnlineStore.Core.DTOs
{
    public class ProductCreateDto
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
        public int StockQuantity { get; set; }
        public Guid CategoryId { get; set; }
        public IFormFile MainImage { get; set; }
        public IFormFile[] AdditionalImages { get; set; }
    }
}

// OnlineStore.Core/DTOs/ProductUpdateDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class ProductUpdateDto
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
        public int StockQuantity { get; set; }
        public Guid CategoryId { get; set; }
    }
}

// OnlineStore.Core/DTOs/CategoryDto.cs
using System;
using System.Collections.Generic;

namespace OnlineStore.Core.DTOs
{
    public class CategoryDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public Guid? ParentId { get; set; }
        public string ParentName { get; set; }
        public List<CategoryDto> Subcategories { get; set; }
    }
}

// OnlineStore.Core/DTOs/CategoryCreateDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class CategoryCreateDto
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public Guid? ParentId { get; set; }
    }
}

// OnlineStore.Core/DTOs/OrderDto.cs
using System;
using System.Collections.Generic;

namespace OnlineStore.Core.DTOs
{
    public class OrderDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public string Username { get; set; }
        public decimal TotalAmount { get; set; }
        public string Status { get; set; }
        public string ShippingAddress { get; set; }
        public string BillingAddress { get; set; }
        public DateTime CreatedAt { get; set; }
        public List<OrderItemDto> Items { get; set; }
    }
}

// OnlineStore.Core/DTOs/OrderItemDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class OrderItemDto
    {
        public Guid Id { get; set; }
        public Guid ProductId { get; set; }
        public string ProductName { get; set; }
        public string ProductImageUrl { get; set; }
        public int Quantity { get; set; }
        public decimal UnitPrice { get; set; }
        public decimal TotalPrice { get; set; }
    }
}

// OnlineStore.Core/DTOs/OrderCreateDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class OrderCreateDto
    {
        public string ShippingAddress { get; set; }
        public string BillingAddress { get; set; }
        // Payment information would go here in a real application
    }
}

// OnlineStore.Core/DTOs/OrderStatusUpdateDto.cs
namespace OnlineStore.Core.DTOs
{
    public class OrderStatusUpdateDto
    {
        public string Status { get; set; }
    }
}

// OnlineStore.Core/DTOs/CartDto.cs
using System;
using System.Collections.Generic;

namespace OnlineStore.Core.DTOs
{
    public class CartDto
    {
        public Guid Id { get; set; }
        public Guid UserId { get; set; }
        public List<CartItemDto> Items { get; set; }
        public decimal TotalAmount { get; set; }
    }
}

// OnlineStore.Core/DTOs/CartItemDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class CartItemDto
    {
        public Guid Id { get; set; }
        public Guid ProductId { get; set; }
        public string ProductName { get; set; }
        public string ProductImageUrl { get; set; }
        public decimal UnitPrice { get; set; }
        public int Quantity { get; set; }
        public decimal TotalPrice { get; set; }
    }
}

// OnlineStore.Core/DTOs/CartItemCreateDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class CartItemCreateDto
    {
        public Guid ProductId { get; set; }
        public int Quantity { get; set; }
    }
}

// OnlineStore.Core/DTOs/CartItemUpdateDto.cs
namespace OnlineStore.Core.DTOs
{
    public class CartItemUpdateDto
    {
        public int Quantity { get; set; }
    }
}

// OnlineStore.Core/DTOs/SearchDto.cs
using System;

namespace OnlineStore.Core.DTOs
{
    public class SearchDto
    {
        public string SearchTerm { get; set; }
        public Guid? CategoryId { get; set; }
        public decimal? MinPrice { get; set; }
        public decimal? MaxPrice { get; set; }
        public int Page { get; set; } = 1;
        public int PageSize { get; set; } = 10;
    }
}

// OnlineStore.Core/DTOs/PaginatedResponse.cs
using System.Collections.Generic;

namespace OnlineStore.Core.DTOs
{
    public class PaginatedResponse<T>
    {
        public List<T> Items { get; set; }
        public int PageIndex { get; set; }
        public int PageSize { get; set; }
        public int TotalCount { get; set; }
        public int TotalPages { get; set; }
        public bool HasPreviousPage { get; set; }
        public bool HasNextPage { get; set; }
    }
}
```

### Service Interfaces

Let's define interfaces for our services:

```csharp
// OnlineStore.Core/Interfaces/IAuthService.cs
using System.Threading.Tasks;
using OnlineStore.Core.DTOs;

namespace OnlineStore.Core.Interfaces
{
    public interface IAuthService
    {
        Task<UserDto> RegisterAsync(RegisterDto registerDto);
        Task<string> LoginAsync(LoginDto loginDto);
        Task<UserDto> GetCurrentUserAsync(string username);
    }
}

// OnlineStore.Core/Interfaces/IProductService.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.DTOs;

namespace OnlineStore.Core.Interfaces
{
    public interface IProductService
    {
        Task<ProductDto> GetProductByIdAsync(Guid id);
        Task<PaginatedResponse<ProductDto>> GetProductsAsync(int page = 1, int pageSize = 10);
        Task<PaginatedResponse<ProductDto>> SearchProductsAsync(SearchDto searchDto);
        Task<PaginatedResponse<ProductDto>> GetProductsByCategoryAsync(Guid categoryId, int page = 1, int pageSize = 10);
        Task<ProductDto> CreateProductAsync(ProductCreateDto productDto);
        Task<ProductDto> UpdateProductAsync(Guid id, ProductUpdateDto productDto);
        Task DeleteProductAsync(Guid id);
    }
}

// OnlineStore.Core/Interfaces/ICategoryService.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.DTOs;

namespace OnlineStore.Core.Interfaces
{
    public interface ICategoryService
    {
        Task<CategoryDto> GetCategoryByIdAsync(Guid id);
        Task<List<CategoryDto>> GetAllCategoriesAsync();
        Task<List<CategoryDto>> GetCategoriesWithSubcategoriesAsync();
        Task<CategoryDto> CreateCategoryAsync(CategoryCreateDto categoryDto);
        Task<CategoryDto> UpdateCategoryAsync(Guid id, CategoryCreateDto categoryDto);
        Task DeleteCategoryAsync(Guid id);
    }
}

// OnlineStore.Core/Interfaces/IOrderService.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.DTOs;

namespace OnlineStore.Core.Interfaces
{
    public interface IOrderService
    {
        Task<OrderDto> GetOrderByIdAsync(Guid id);
        Task<List<OrderDto>> GetOrdersByUserIdAsync(Guid userId);
        Task<PaginatedResponse<OrderDto>> GetOrdersByStatusAsync(string status, int page = 1, int pageSize = 10);
        Task<OrderDto> CreateOrderAsync(Guid userId, OrderCreateDto orderDto);
        Task<OrderDto> UpdateOrderStatusAsync(Guid id, OrderStatusUpdateDto statusDto);
        Task<PaginatedResponse<OrderDto>> GetAllOrdersAsync(int page = 1, int pageSize = 10);
    }
}

// OnlineStore.Core/Interfaces/ICartService.cs
using System;
using System.Threading.Tasks;
using OnlineStore.Core.DTOs;

namespace OnlineStore.Core.Interfaces
{
    public interface ICartService
    {
        Task<CartDto> GetCartAsync(Guid userId);
        Task<CartDto> AddItemToCartAsync(Guid userId, CartItemCreateDto itemDto);
        Task<CartDto> UpdateCartItemAsync(Guid userId, Guid cartItemId, CartItemUpdateDto itemDto);
        Task<CartDto> RemoveCartItemAsync(Guid userId, Guid cartItemId);
        Task ClearCartAsync(Guid userId);
    }
}

// OnlineStore.Core/Interfaces/IUserService.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OnlineStore.Core.DTOs;

namespace OnlineStore.Core.Interfaces
{
    public interface IUserService
    {
        Task<UserDto> GetUserByIdAsync(Guid id);
        Task<List<UserDto>> GetAllUsersAsync();
        Task<List<UserDto>> GetUsersByRoleAsync(string role);
        Task<UserDto> UpdateUserRoleAsync(Guid id, string role);
        Task DeleteUserAsync(Guid id);
    }
}

// OnlineStore.Core/Interfaces/IStatisticsService.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace OnlineStore.Core.Interfaces
{
    public interface IStatisticsService
    {
        Task<Dictionary<string, int>> GetOrdersCountByStatusAsync();
        Task<Dictionary<string, decimal>> GetSalesByTimeRangeAsync(DateTime startDate, DateTime endDate, string groupBy);
        Task<List<KeyValuePair<string, int>>> GetTopSellingProductsAsync(int count);
        Task<Dictionary<string, decimal>> GetSalesByCategoryAsync();
    }
}
```

## Infrastructure Project Implementation

Now, let's implement the Infrastructure project, which contains our data access and external service implementations.

### DbContext Implementation

```csharp
// OnlineStore.Infrastructure/Data/ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using OnlineStore.Core.Entities;

namespace OnlineStore.Infrastructure.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
            : base(options)
        {
        }
        
        public DbSet<User> Users { get; set; }
        public DbSet<Category> Categories { get; set; }
        public DbSet<Product> Products { get; set; }
        public DbSet<ProductImage> ProductImages { get; set; }
        public DbSet<Order> Orders { get; set; }
        public DbSet<OrderItem> OrderItems { get; set; }
        public DbSet<ShoppingCart> ShoppingCarts { get; set; }
        public DbSet<CartItem> CartItems { get; set; }
        public DbSet<ProductReview> ProductReviews { get; set; }
        
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            
            // Configure User entity
            modelBuilder.Entity<User>(entity =>
            {
                entity.ToTable("Users");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Username).IsRequired().HasMaxLength(50);
                entity.Property(e => e.Email).IsRequired().HasMaxLength(100);
                entity.Property(e => e.PasswordHash).IsRequired().HasMaxLength(255);
                entity.Property(e => e.Role).IsRequired().HasMaxLength(20);
                entity.HasIndex(e => e.Username).IsUnique();
                entity.HasIndex(e => e.Email).IsUnique();
            });
            
            // Configure Category entity
            modelBuilder.Entity<Category>(entity =>
            {
                entity.ToTable("Categories");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name).IsRequired().HasMaxLength(100);
                entity.HasOne(e => e.ParentCategory)
                      .WithMany(e => e.Subcategories)
                      .HasForeignKey(e => e.ParentId)
                      .IsRequired(false)
                      .OnDelete(DeleteBehavior.Restrict);
            });
            
            // Configure Product entity
            modelBuilder.Entity<Product>(entity =>
            {
                entity.ToTable("Products");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Name).IsRequired().HasMaxLength(200);
                entity.Property(e => e.Price).IsRequired().HasColumnType("decimal(10, 2)");
                entity.Property(e => e.StockQuantity).IsRequired();
                entity.HasOne(e => e.Category)
                      .WithMany(e => e.Products)
                      .HasForeignKey(e => e.CategoryId)
                      .OnDelete(DeleteBehavior.Restrict);
                
                // Configure tsvector column
                entity.Property(e => e.SearchVector)
                      .HasColumnType("tsvector")
                      .HasAnnotation("Npgsql:TsVectorConfig", "english")
                      .HasAnnotation("Npgsql:TsVectorProperties", new[] { "Name", "Description" });
                
                // Create index for tsvector
                entity.HasIndex(e => e.SearchVector)
                      .HasMethod("GIN");
            });
            
            // Configure ProductImage entity
            modelBuilder.Entity<ProductImage>(entity =>
            {
                entity.ToTable("ProductImages");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.ImageUrl).IsRequired().HasMaxLength(255);
                entity.HasOne(e => e.Product)
                      .WithMany(e => e.Images)
                      .HasForeignKey(e => e.ProductId)
                      .OnDelete(DeleteBehavior.Cascade);
            });
            
            // Configure Order entity
            modelBuilder.Entity<Order>(entity =>
            {
                entity.ToTable("Orders");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.TotalAmount).IsRequired().HasColumnType("decimal(10, 2)");
                entity.Property(e => e.Status).IsRequired().HasMaxLength(20);
                entity.Property(e => e.ShippingAddress).IsRequired();
                entity.Property(e => e.BillingAddress).IsRequired();
                entity.HasOne(e => e.User)
                      .WithMany(e => e.Orders)
                      .HasForeignKey(e => e.UserId)
                      .OnDelete(DeleteBehavior.Restrict);
            });
            
            // Configure OrderItem entity
            modelBuilder.Entity<OrderItem>(entity =>
            {
                entity.ToTable("OrderItems");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Quantity).IsRequired();
                entity.Property(e => e.UnitPrice).IsRequired().HasColumnType("decimal(10, 2)");
                entity.HasOne(e => e.Order)
                      .WithMany(e => e.OrderItems)
                      .HasForeignKey(e => e.OrderId)
                      .OnDelete(DeleteBehavior.Cascade);
                entity.HasOne(e => e.Product)
                      .WithMany(e => e.OrderItems)
                      .HasForeignKey(e => e.ProductId)
                      .OnDelete(DeleteBehavior.Restrict);
            });
            
            // Configure ShoppingCart entity
            modelBuilder.Entity<ShoppingCart>(entity =>
            {
                entity.ToTable("ShoppingCarts");
                entity.HasKey(e => e.Id);
                entity.HasOne(e => e.User)
                      .WithOne(e => e.Cart)
                      .HasForeignKey<ShoppingCart>(e => e.UserId)
                      .OnDelete(DeleteBehavior.Cascade);
            });
            
            // Configure CartItem entity
            modelBuilder.Entity<CartItem>(entity =>
            {
                entity.ToTable("CartItems");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Quantity).IsRequired();
                entity.HasOne(e => e.Cart)
                      .WithMany(e => e.CartItems)
                      .HasForeignKey(e => e.CartId)
                      .OnDelete(DeleteBehavior.Cascade);
                entity.HasOne(e => e.Product)
                      .WithMany()
                      .HasForeignKey(e => e.ProductId)
                      .OnDelete(DeleteBehavior.Restrict);
            });
            
            // Configure ProductReview entity
            modelBuilder.Entity<ProductReview>(entity =>
            {
                entity.ToTable("ProductReviews");
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Rating).IsRequired();
                entity.HasOne(e => e.Product)
                      .WithMany(e => e.Reviews)
                      .HasForeignKey(e => e.ProductId)
                      .OnDelete(DeleteBehavior.Cascade);
                entity.HasOne(e => e.User)
                      .WithMany()
                      .HasForeignKey(e => e.UserId)
                      .OnDelete(DeleteBehavior.Restrict);
            });
        }
    }
}
```

### Repository Implementations

```csharp
// OnlineStore.Infrastructure/Repositories/Repository.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Data;

namespace OnlineStore.Infrastructure.Repositories
{
    public class Repository<T> : IRepository<T> where T : BaseEntity
    {
        protected readonly ApplicationDbContext _context;
        
        public Repository(ApplicationDbContext context)
        {
            _context = context;
        }
        
        public async Task<T> GetByIdAsync(Guid id)
        {
            return await _context.Set<T>().FindAsync(id);
        }
        
        public async Task<IReadOnlyList<T>> ListAllAsync()
        {
            return await _context.Set<T>().ToListAsync();
        }
        
        public async Task<IReadOnlyList<T>> ListAsync(Expression<Func<T, bool>> predicate)
        {
            return await _context.Set<T>().Where(predicate).ToListAsync();
        }
        
        public async Task<T> AddAsync(T entity)
        {
            entity.CreatedAt = DateTime.UtcNow;
            _context.Set<T>().Add(entity);
            await _context.SaveChangesAsync();
            return entity;
        }
        
        public async Task UpdateAsync(T entity)
        {
            entity.UpdatedAt = DateTime.UtcNow;
            _context.Entry(entity).State = EntityState.Modified;
            await _context.SaveChangesAsync();
        }
        
        public async Task DeleteAsync(T entity)
        {
            _context.Set<T>().Remove(entity);
            await _context.SaveChangesAsync();
        }
        
        public async Task<int> CountAsync(Expression<Func<T, bool>> predicate)
        {
            return await _context.Set<T>().CountAsync(predicate);
        }
    }
}

// OnlineStore.Infrastructure/Repositories/ProductRepository.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using NpgsqlTypes;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Data;

namespace OnlineStore.Infrastructure.Repositories
{
    public class ProductRepository : Repository<Product>, IProductRepository
    {
        public ProductRepository(ApplicationDbContext context) : base(context)
        {
        }
        
        public async Task<IReadOnlyList<Product>> SearchProductsAsync(
            string searchTerm, 
            Guid? categoryId = null, 
            decimal? minPrice = null, 
            decimal? maxPrice = null, 
            int page = 1, 
            int pageSize = 10)
        {
            // Start with a query that includes related data
            var query = _context.Products
                .Include(p => p.Category)
                .Include(p => p.Images.Where(i => i.IsMain))
                .AsQueryable();
            
            // Apply search term if provided
            if (!string.IsNullOrWhiteSpace(searchTerm))
            {
                // Convert search term to tsquery
                var tsQuery = NpgsqlTsQuery.Parse(searchTerm.Replace(' ', '&'));
                
                // Filter by search vector match
                query = query.Where(p => p.SearchVector.Matches(tsQuery));
                
                // Order by rank
                query = query.OrderByDescending(p => EF.Functions.MatchTsVector(p.SearchVector, tsQuery));
            }
            else
            {
                // Default ordering if no search term
                query = query.OrderByDescending(p => p.CreatedAt);
            }
            
            // Apply category filter if provided
            if (categoryId.HasValue)
            {
                query = query.Where(p => p.CategoryId == categoryId.Value);
            }
            
            // Apply price range filters if provided
            if (minPrice.HasValue)
            {
                query = query.Where(p => p.Price >= minPrice.Value);
            }
            
            if (maxPrice.HasValue)
            {
                query = query.Where(p => p.Price <= maxPrice.Value);
            }
            
            // Apply pagination
            var skip = (page - 1) * pageSize;
            return await query.Skip(skip).Take(pageSize).ToListAsync();
        }
        
        public async Task<int> CountSearchResultsAsync(
            string searchTerm, 
            Guid? categoryId = null, 
            decimal? minPrice = null, 
            decimal? maxPrice = null)
        {
            var query = _context.Products.AsQueryable();
            
            // Apply search term if provided
            if (!string.IsNullOrWhiteSpace(searchTerm))
            {
                // Convert search term to tsquery
                var tsQuery = NpgsqlTsQuery.Parse(searchTerm.Replace(' ', '&'));
                
                // Filter by search vector match
                query = query.Where(p => p.SearchVector.Matches(tsQuery));
            }
            
            // Apply category filter if provided
            if (categoryId.HasValue)
            {
                query = query.Where(p => p.CategoryId == categoryId.Value);
            }
            
            // Apply price range filters if provided
            if (minPrice.HasValue)
            {
                query = query.Where(p => p.Price >= minPrice.Value);
            }
            
            if (maxPrice.HasValue)
            {
                query = query.Where(p => p.Price <= maxPrice.Value);
            }
            
            return await query.CountAsync();
        }
        
        public async Task<IReadOnlyList<Product>> GetProductsByCategoryAsync(Guid categoryId, int page = 1, int pageSize = 10)
        {
            var skip = (page - 1) * pageSize;
            
            return await _context.Products
                .Include(p => p.Category)
                .Include(p => p.Images.Where(i => i.IsMain))
                .Where(p => p.CategoryId == categoryId)
                .OrderByDescending(p => p.CreatedAt)
                .Skip(skip)
                .Take(pageSize)
                .ToListAsync();
        }
        
        public async Task<Product> GetProductWithDetailsAsync(Guid id)
        {
            return await _context.Products
                .Include(p => p.Category)
                .Include(p => p.Images)
                .Include(p => p.Reviews)
                    .ThenInclude(r => r.User)
                .FirstOrDefaultAsync(p => p.Id == id);
        }
        
        public async Task UpdateStockQuantityAsync(Guid id, int quantity)
        {
            var product = await _context.Products.FindAsync(id);
            if (product != null)
            {
                product.StockQuantity = quantity;
                product.UpdatedAt = DateTime.UtcNow;
                await _context.SaveChangesAsync();
            }
        }
    }
}

// Implement other repositories (UserRepository, OrderRepository, CategoryRepository, ShoppingCartRepository)
// following similar patterns
```

### Service Implementations

```csharp
// OnlineStore.Infrastructure/Services/ProductService.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using AutoMapper;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.Infrastructure.Services
{
    public class ProductService : IProductService
    {
        private readonly IProductRepository _productRepository;
        private readonly IMapper _mapper;
        private readonly IWebHostEnvironment _environment;
        
        public ProductService(
            IProductRepository productRepository,
            IMapper mapper,
            IWebHostEnvironment environment)
        {
            _productRepository = productRepository;
            _mapper = mapper;
            _environment = environment;
        }
        
        public async Task<ProductDto> GetProductByIdAsync(Guid id)
        {
            var product = await _productRepository.GetProductWithDetailsAsync(id);
            return _mapper.Map<ProductDto>(product);
        }
        
        public async Task<PaginatedResponse<ProductDto>> GetProductsAsync(int page = 1, int pageSize = 10)
        {
            var products = await _productRepository.SearchProductsAsync(null, null, null, null, page, pageSize);
            var totalCount = await _productRepository.CountAsync(p => true);
            
            var productDtos = _mapper.Map<List<ProductDto>>(products);
            
            return new PaginatedResponse<ProductDto>
            {
                Items = productDtos,
                PageIndex = page,
                PageSize = pageSize,
                TotalCount = totalCount,
                TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize),
                HasPreviousPage = page > 1,
                HasNextPage = page < (int)Math.Ceiling(totalCount / (double)pageSize)
            };
        }
        
        public async Task<PaginatedResponse<ProductDto>> SearchProductsAsync(SearchDto searchDto)
        {
            var products = await _productRepository.SearchProductsAsync(
                searchDto.SearchTerm,
                searchDto.CategoryId,
                searchDto.MinPrice,
                searchDto.MaxPrice,
                searchDto.Page,
                searchDto.PageSize);
                
            var totalCount = await _productRepository.CountSearchResultsAsync(
                searchDto.SearchTerm,
                searchDto.CategoryId,
                searchDto.MinPrice,
                searchDto.MaxPrice);
                
            var productDtos = _mapper.Map<List<ProductDto>>(products);
            
            return new PaginatedResponse<ProductDto>
            {
                Items = productDtos,
                PageIndex = searchDto.Page,
                PageSize = searchDto.PageSize,
                TotalCount = totalCount,
                TotalPages = (int)Math.Ceiling(totalCount / (double)searchDto.PageSize),
                HasPreviousPage = searchDto.Page > 1,
                HasNextPage = searchDto.Page < (int)Math.Ceiling(totalCount / (double)searchDto.PageSize)
            };
        }
        
        public async Task<PaginatedResponse<ProductDto>> GetProductsByCategoryAsync(Guid categoryId, int page = 1, int pageSize = 10)
        {
            var products = await _productRepository.GetProductsByCategoryAsync(categoryId, page, pageSize);
            var totalCount = await _productRepository.CountAsync(p => p.CategoryId == categoryId);
            
            var productDtos = _mapper.Map<List<ProductDto>>(products);
            
            return new PaginatedResponse<ProductDto>
            {
                Items = productDtos,
                PageIndex = page,
                PageSize = pageSize,
                TotalCount = totalCount,
                TotalPages = (int)Math.Ceiling(totalCount / (double)pageSize),
                HasPreviousPage = page > 1,
                HasNextPage = page < (int)Math.Ceiling(totalCount / (double)pageSize)
            };
        }
        
        public async Task<ProductDto> CreateProductAsync(ProductCreateDto productDto)
        {
            var product = _mapper.Map<Product>(productDto);
            product = await _productRepository.AddAsync(product);
            
            // Handle image uploads
            if (productDto.MainImage != null)
            {
                var mainImagePath = await SaveImageAsync(productDto.MainImage);
                var mainImage = new ProductImage
                {
                    ProductId = product.Id,
                    ImageUrl = mainImagePath,
                    IsMain = true,
                    CreatedAt = DateTime.UtcNow
                };
                
                // Add main image to database
                // In a real implementation, you would use a repository for this
                // For simplicity, we're using the product repository
                product.Images = new List<ProductImage> { mainImage };
            }
            
            if (productDto.AdditionalImages != null && productDto.AdditionalImages.Length > 0)
            {
                foreach (var image in productDto.AdditionalImages)
                {
                    var imagePath = await SaveImageAsync(image);
                    var productImage = new ProductImage
                    {
                        ProductId = product.Id,
                        ImageUrl = imagePath,
                        IsMain = false,
                        CreatedAt = DateTime.UtcNow
                    };
                    
                    product.Images.Add(productImage);
                }
            }
            
            await _productRepository.UpdateAsync(product);
            
            return _mapper.Map<ProductDto>(product);
        }
        
        public async Task<ProductDto> UpdateProductAsync(Guid id, ProductUpdateDto productDto)
        {
            var product = await _productRepository.GetByIdAsync(id);
            if (product == null)
            {
                throw new Exception($"Product with ID {id} not found");
            }
            
            _mapper.Map(productDto, product);
            await _productRepository.UpdateAsync(product);
            
            return _mapper.Map<ProductDto>(product);
        }
        
        public async Task DeleteProductAsync(Guid id)
        {
            var product = await _productRepository.GetByIdAsync(id);
            if (product == null)
            {
                throw new Exception($"Product with ID {id} not found");
            }
            
            await _productRepository.DeleteAsync(product);
        }
        
        private async Task<string> SaveImageAsync(IFormFile image)
        {
            var uploadsFolder = System.IO.Path.Combine(_environment.WebRootPath, "images", "products");
            if (!System.IO.Directory.Exists(uploadsFolder))
            {
                System.IO.Directory.CreateDirectory(uploadsFolder);
            }
            
            var uniqueFileName = Guid.NewGuid().ToString() + "_" + image.FileName;
            var filePath = System.IO.Path.Combine(uploadsFolder, uniqueFileName);
            
            using (var fileStream = new System.IO.FileStream(filePath, System.IO.FileMode.Create))
            {
                await image.CopyToAsync(fileStream);
            }
            
            return "/images/products/" + uniqueFileName;
        }
    }
}

// Implement other services (AuthService, CategoryService, OrderService, CartService, UserService, StatisticsService)
// following similar patterns
```

### AutoMapper Configuration

```csharp
// OnlineStore.Infrastructure/Mapping/MappingProfile.cs
using AutoMapper;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Entities;

namespace OnlineStore.Infrastructure.Mapping
{
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            // User mappings
            CreateMap<User, UserDto>();
            CreateMap<RegisterDto, User>();
            
            // Product mappings
            CreateMap<Product, ProductDto>()
                .ForMember(dest => dest.CategoryName, opt => opt.MapFrom(src => src.Category.Name))
                .ForMember(dest => dest.MainImageUrl, opt => opt.MapFrom(src => 
                    src.Images.FirstOrDefault(i => i.IsMain) != null ? 
                    src.Images.First(i => i.IsMain).ImageUrl : null))
                .ForMember(dest => dest.ImageUrls, opt => opt.MapFrom(src => 
                    src.Images.Select(i => i.ImageUrl).ToList()));
                    
            CreateMap<ProductCreateDto, Product>();
            CreateMap<ProductUpdateDto, Product>();
            
            // Category mappings
            CreateMap<Category, CategoryDto>()
                .ForMember(dest => dest.ParentName, opt => opt.MapFrom(src => 
                    src.ParentCategory != null ? src.ParentCategory.Name : null))
                .ForMember(dest => dest.Subcategories, opt => opt.MapFrom(src => src.Subcategories));
                
            CreateMap<CategoryCreateDto, Category>();
            
            // Order mappings
            CreateMap<Order, OrderDto>()
                .ForMember(dest => dest.Username, opt => opt.MapFrom(src => src.User.Username))
                .ForMember(dest => dest.Items, opt => opt.MapFrom(src => src.OrderItems));
                
            CreateMap<OrderCreateDto, Order>();
            
            // OrderItem mappings
            CreateMap<OrderItem, OrderItemDto>()
                .ForMember(dest => dest.ProductName, opt => opt.MapFrom(src => src.Product.Name))
                .ForMember(dest => dest.ProductImageUrl, opt => opt.MapFrom(src => 
                    src.Product.Images.FirstOrDefault(i => i.IsMain) != null ? 
                    src.Product.Images.First(i => i.IsMain).ImageUrl : null))
                .ForMember(dest => dest.TotalPrice, opt => opt.MapFrom(src => src.Quantity * src.UnitPrice));
                
            // Cart mappings
            CreateMap<ShoppingCart, CartDto>()
                .ForMember(dest => dest.Items, opt => opt.MapFrom(src => src.CartItems))
                .ForMember(dest => dest.TotalAmount, opt => opt.MapFrom(src => 
                    src.CartItems.Sum(i => i.Quantity * i.Product.Price)));
                    
            // CartItem mappings
            CreateMap<CartItem, CartItemDto>()
                .ForMember(dest => dest.ProductName, opt => opt.MapFrom(src => src.Product.Name))
                .ForMember(dest => dest.ProductImageUrl, opt => opt.MapFrom(src => 
                    src.Product.Images.FirstOrDefault(i => i.IsMain) != null ? 
                    src.Product.Images.First(i => i.IsMain).ImageUrl : null))
                .ForMember(dest => dest.UnitPrice, opt => opt.MapFrom(src => src.Product.Price))
                .ForMember(dest => dest.TotalPrice, opt => opt.MapFrom(src => src.Quantity * src.Product.Price));
                
            CreateMap<CartItemCreateDto, CartItem>();
        }
    }
}
```

## API Project Implementation

Now, let's implement the API controllers and configure the application.

### Program.cs Configuration

```csharp
// OnlineStore.API/Program.cs
using System.Text;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Data;
using OnlineStore.Infrastructure.Mapping;
using OnlineStore.Infrastructure.Repositories;
using OnlineStore.Infrastructure.Services;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddControllers();

// Add DbContext
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(
        builder.Configuration.GetConnectionString("DefaultConnection"),
        npgsqlOptions => npgsqlOptions.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)
    )
);

// Add AutoMapper
builder.Services.AddAutoMapper(typeof(MappingProfile));

// Add repositories
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
builder.Services.AddScoped<IProductRepository, ProductRepository>();
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<ICategoryRepository, CategoryRepository>();
builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<IShoppingCartRepository, ShoppingCartRepository>();

// Add services
builder.Services.AddScoped<IAuthService, AuthService>();
builder.Services.AddScoped<IProductService, ProductService>();
builder.Services.AddScoped<ICategoryService, CategoryService>();
builder.Services.AddScoped<IOrderService, OrderService>();
builder.Services.AddScoped<ICartService, CartService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddScoped<IStatisticsService, StatisticsService>();

// Add JWT Authentication
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(
                builder.Configuration["Jwt:Key"])),
            ValidateIssuer = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidateAudience = true,
            ValidAudience = builder.Configuration["Jwt:Audience"],
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
    });

// Add Swagger
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "OnlineStore API", Version = "v1" });
    
    // Add JWT Authentication to Swagger
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer"
    });
    
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] { }
        }
    });
});

// Add CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", builder =>
        builder.AllowAnyOrigin()
               .AllowAnyMethod()
               .AllowAnyHeader());
});

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseCors("AllowAll");

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

// Apply migrations and seed data in development
if (app.Environment.IsDevelopment())
{
    using (var scope = app.Services.CreateScope())
    {
        var services = scope.ServiceProvider;
        try
        {
            var context = services.GetRequiredService<ApplicationDbContext>();
            context.Database.Migrate();
            
            // Seed data
            // var seeder = services.GetRequiredService<DbSeeder>();
            // await seeder.SeedAsync();
        }
        catch (Exception ex)
        {
            var logger = services.GetRequiredService<ILogger<Program>>();
            logger.LogError(ex, "An error occurred during migration");
        }
    }
}

app.Run();
```

### appsettings.json Configuration

```json
// OnlineStore.API/appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=onlinestore;Username=storeapp;Password=StrongPassword123!"
  },
  "Jwt": {
    "Key": "ThisIsAVerySecureKeyThatShouldBeAtLeast32CharactersLong",
    "Issuer": "OnlineStore",
    "Audience": "OnlineStoreClients",
    "DurationInMinutes": 60
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

### API Controllers

Let's implement the API controllers for our application:

```csharp
// OnlineStore.API/Controllers/AuthController.cs
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly IAuthService _authService;
        
        public AuthController(IAuthService authService)
        {
            _authService = authService;
        }
        
        [HttpPost("register")]
        public async Task<ActionResult<UserDto>> Register(RegisterDto registerDto)
        {
            var user = await _authService.RegisterAsync(registerDto);
            return Ok(user);
        }
        
        [HttpPost("login")]
        public async Task<ActionResult<string>> Login(LoginDto loginDto)
        {
            var token = await _authService.LoginAsync(loginDto);
            return Ok(new { token });
        }
        
        [HttpGet("me")]
        public async Task<ActionResult<UserDto>> GetCurrentUser()
        {
            var username = User.Identity.Name;
            var user = await _authService.GetCurrentUserAsync(username);
            return Ok(user);
        }
    }
}

// OnlineStore.API/Controllers/ProductsController.cs
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ProductsController : ControllerBase
    {
        private readonly IProductService _productService;
        
        public ProductsController(IProductService productService)
        {
            _productService = productService;
        }
        
        [HttpGet]
        public async Task<ActionResult<PaginatedResponse<ProductDto>>> GetProducts(
            [FromQuery] int page = 1, 
            [FromQuery] int pageSize = 10)
        {
            var products = await _productService.GetProductsAsync(page, pageSize);
            return Ok(products);
        }
        
        [HttpGet("{id}")]
        public async Task<ActionResult<ProductDto>> GetProduct(Guid id)
        {
            var product = await _productService.GetProductByIdAsync(id);
            if (product == null)
            {
                return NotFound();
            }
            
            return Ok(product);
        }
        
        [HttpGet("search")]
        public async Task<ActionResult<PaginatedResponse<ProductDto>>> SearchProducts([FromQuery] SearchDto searchDto)
        {
            var products = await _productService.SearchProductsAsync(searchDto);
            return Ok(products);
        }
        
        [HttpGet("category/{categoryId}")]
        public async Task<ActionResult<PaginatedResponse<ProductDto>>> GetProductsByCategory(
            Guid categoryId, 
            [FromQuery] int page = 1, 
            [FromQuery] int pageSize = 10)
        {
            var products = await _productService.GetProductsByCategoryAsync(categoryId, page, pageSize);
            return Ok(products);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpPost]
        public async Task<ActionResult<ProductDto>> CreateProduct([FromForm] ProductCreateDto productDto)
        {
            var product = await _productService.CreateProductAsync(productDto);
            return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpPut("{id}")]
        public async Task<ActionResult<ProductDto>> UpdateProduct(Guid id, ProductUpdateDto productDto)
        {
            try
            {
                var product = await _productService.UpdateProductAsync(id, productDto);
                return Ok(product);
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpDelete("{id}")]
        public async Task<ActionResult> DeleteProduct(Guid id)
        {
            try
            {
                await _productService.DeleteProductAsync(id);
                return NoContent();
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
    }
}

// OnlineStore.API/Controllers/CategoriesController.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class CategoriesController : ControllerBase
    {
        private readonly ICategoryService _categoryService;
        
        public CategoriesController(ICategoryService categoryService)
        {
            _categoryService = categoryService;
        }
        
        [HttpGet]
        public async Task<ActionResult<List<CategoryDto>>> GetCategories()
        {
            var categories = await _categoryService.GetAllCategoriesAsync();
            return Ok(categories);
        }
        
        [HttpGet("with-subcategories")]
        public async Task<ActionResult<List<CategoryDto>>> GetCategoriesWithSubcategories()
        {
            var categories = await _categoryService.GetCategoriesWithSubcategoriesAsync();
            return Ok(categories);
        }
        
        [HttpGet("{id}")]
        public async Task<ActionResult<CategoryDto>> GetCategory(Guid id)
        {
            var category = await _categoryService.GetCategoryByIdAsync(id);
            if (category == null)
            {
                return NotFound();
            }
            
            return Ok(category);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpPost]
        public async Task<ActionResult<CategoryDto>> CreateCategory(CategoryCreateDto categoryDto)
        {
            var category = await _categoryService.CreateCategoryAsync(categoryDto);
            return CreatedAtAction(nameof(GetCategory), new { id = category.Id }, category);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpPut("{id}")]
        public async Task<ActionResult<CategoryDto>> UpdateCategory(Guid id, CategoryCreateDto categoryDto)
        {
            try
            {
                var category = await _categoryService.UpdateCategoryAsync(id, categoryDto);
                return Ok(category);
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpDelete("{id}")]
        public async Task<ActionResult> DeleteCategory(Guid id)
        {
            try
            {
                await _categoryService.DeleteCategoryAsync(id);
                return NoContent();
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
    }
}

// OnlineStore.API/Controllers/OrdersController.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize]
    public class OrdersController : ControllerBase
    {
        private readonly IOrderService _orderService;
        
        public OrdersController(IOrderService orderService)
        {
            _orderService = orderService;
        }
        
        [HttpGet]
        public async Task<ActionResult<List<OrderDto>>> GetUserOrders()
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var orders = await _orderService.GetOrdersByUserIdAsync(userId);
            return Ok(orders);
        }
        
        [HttpGet("{id}")]
        public async Task<ActionResult<OrderDto>> GetOrder(Guid id)
        {
            var order = await _orderService.GetOrderByIdAsync(id);
            if (order == null)
            {
                return NotFound();
            }
            
            // Check if the order belongs to the current user or if the user is a manager/admin
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var userRole = User.FindFirst("Role")?.Value;
            
            if (order.UserId != userId && userRole != "Manager" && userRole != "Admin")
            {
                return Forbid();
            }
            
            return Ok(order);
        }
        
        [HttpPost]
        public async Task<ActionResult<OrderDto>> CreateOrder(OrderCreateDto orderDto)
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var order = await _orderService.CreateOrderAsync(userId, orderDto);
            return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpGet("all")]
        public async Task<ActionResult<PaginatedResponse<OrderDto>>> GetAllOrders(
            [FromQuery] int page = 1, 
            [FromQuery] int pageSize = 10)
        {
            var orders = await _orderService.GetAllOrdersAsync(page, pageSize);
            return Ok(orders);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpGet("status/{status}")]
        public async Task<ActionResult<PaginatedResponse<OrderDto>>> GetOrdersByStatus(
            string status, 
            [FromQuery] int page = 1, 
            [FromQuery] int pageSize = 10)
        {
            var orders = await _orderService.GetOrdersByStatusAsync(status, page, pageSize);
            return Ok(orders);
        }
        
        [Authorize(Roles = "Manager,Admin")]
        [HttpPut("{id}/status")]
        public async Task<ActionResult<OrderDto>> UpdateOrderStatus(Guid id, OrderStatusUpdateDto statusDto)
        {
            try
            {
                var order = await _orderService.UpdateOrderStatusAsync(id, statusDto);
                return Ok(order);
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
    }
}

// OnlineStore.API/Controllers/CartController.cs
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize]
    public class CartController : ControllerBase
    {
        private readonly ICartService _cartService;
        
        public CartController(ICartService cartService)
        {
            _cartService = cartService;
        }
        
        [HttpGet]
        public async Task<ActionResult<CartDto>> GetCart()
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var cart = await _cartService.GetCartAsync(userId);
            return Ok(cart);
        }
        
        [HttpPost("items")]
        public async Task<ActionResult<CartDto>> AddItemToCart(CartItemCreateDto itemDto)
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var cart = await _cartService.AddItemToCartAsync(userId, itemDto);
            return Ok(cart);
        }
        
        [HttpPut("items/{itemId}")]
        public async Task<ActionResult<CartDto>> UpdateCartItem(Guid itemId, CartItemUpdateDto itemDto)
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var cart = await _cartService.UpdateCartItemAsync(userId, itemId, itemDto);
            return Ok(cart);
        }
        
        [HttpDelete("items/{itemId}")]
        public async Task<ActionResult<CartDto>> RemoveCartItem(Guid itemId)
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            var cart = await _cartService.RemoveCartItemAsync(userId, itemId);
            return Ok(cart);
        }
        
        [HttpDelete("clear")]
        public async Task<ActionResult> ClearCart()
        {
            var userId = Guid.Parse(User.FindFirst("UserId")?.Value);
            await _cartService.ClearCartAsync(userId);
            return NoContent();
        }
    }
}

// OnlineStore.API/Controllers/UsersController.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize(Roles = "Admin")]
    public class UsersController : ControllerBase
    {
        private readonly IUserService _userService;
        
        public UsersController(IUserService userService)
        {
            _userService = userService;
        }
        
        [HttpGet]
        public async Task<ActionResult<List<UserDto>>> GetUsers()
        {
            var users = await _userService.GetAllUsersAsync();
            return Ok(users);
        }
        
        [HttpGet("{id}")]
        public async Task<ActionResult<UserDto>> GetUser(Guid id)
        {
            var user = await _userService.GetUserByIdAsync(id);
            if (user == null)
            {
                return NotFound();
            }
            
            return Ok(user);
        }
        
        [HttpGet("role/{role}")]
        public async Task<ActionResult<List<UserDto>>> GetUsersByRole(string role)
        {
            var users = await _userService.GetUsersByRoleAsync(role);
            return Ok(users);
        }
        
        [HttpPut("{id}/role")]
        public async Task<ActionResult<UserDto>> UpdateUserRole(Guid id, [FromBody] string role)
        {
            try
            {
                var user = await _userService.UpdateUserRoleAsync(id, role);
                return Ok(user);
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
        
        [HttpDelete("{id}")]
        public async Task<ActionResult> DeleteUser(Guid id)
        {
            try
            {
                await _userService.DeleteUserAsync(id);
                return NoContent();
            }
            catch (Exception ex)
            {
                return NotFound(ex.Message);
            }
        }
    }
}

// OnlineStore.API/Controllers/StatisticsController.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize(Roles = "Manager,Admin")]
    public class StatisticsController : ControllerBase
    {
        private readonly IStatisticsService _statisticsService;
        
        public StatisticsController(IStatisticsService statisticsService)
        {
            _statisticsService = statisticsService;
        }
        
        [HttpGet("orders-by-status")]
        public async Task<ActionResult<Dictionary<string, int>>> GetOrdersCountByStatus()
        {
            var statistics = await _statisticsService.GetOrdersCountByStatusAsync();
            return Ok(statistics);
        }
        
        [HttpGet("sales")]
        public async Task<ActionResult<Dictionary<string, decimal>>> GetSalesByTimeRange(
            [FromQuery] DateTime startDate, 
            [FromQuery] DateTime endDate, 
            [FromQuery] string groupBy = "day")
        {
            var statistics = await _statisticsService.GetSalesByTimeRangeAsync(startDate, endDate, groupBy);
            return Ok(statistics);
        }
        
        [HttpGet("top-selling-products")]
        public async Task<ActionResult<List<KeyValuePair<string, int>>>> GetTopSellingProducts([FromQuery] int count = 5)
        {
            var statistics = await _statisticsService.GetTopSellingProductsAsync(count);
            return Ok(statistics);
        }
        
        [HttpGet("sales-by-category")]
        public async Task<ActionResult<Dictionary<string, decimal>>> GetSalesByCategory()
        {
            var statistics = await _statisticsService.GetSalesByCategoryAsync();
            return Ok(statistics);
        }
    }
}
```

## Unit Testing

Let's implement some unit tests for our application:

```csharp
// OnlineStore.Tests/ProductServiceTests.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using AutoMapper;
using Microsoft.AspNetCore.Hosting;
using Moq;
using OnlineStore.Core.DTOs;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Mapping;
using OnlineStore.Infrastructure.Services;
using Xunit;

namespace OnlineStore.Tests
{
    public class ProductServiceTests
    {
        private readonly Mock<IProductRepository> _mockProductRepository;
        private readonly IMapper _mapper;
        private readonly Mock<IWebHostEnvironment> _mockEnvironment;
        private readonly ProductService _productService;
        
        public ProductServiceTests()
        {
            _mockProductRepository = new Mock<IProductRepository>();
            
            // Configure AutoMapper
            var mapperConfig = new MapperConfiguration(cfg =>
            {
                cfg.AddProfile(new MappingProfile());
            });
            _mapper = mapperConfig.CreateMapper();
            
            _mockEnvironment = new Mock<IWebHostEnvironment>();
            _mockEnvironment.Setup(e => e.WebRootPath).Returns("wwwroot");
            
            _productService = new ProductService(
                _mockProductRepository.Object,
                _mapper,
                _mockEnvironment.Object);
        }
        
        [Fact]
        public async Task GetProductByIdAsync_ShouldReturnProduct_WhenProductExists()
        {
            // Arrange
            var productId = Guid.NewGuid();
            var category = new Category
            {
                Id = Guid.NewGuid(),
                Name = "Test Category"
            };
            
            var product = new Product
            {
                Id = productId,
                Name = "Test Product",
                Description = "Test Description",
                Price = 99.99m,
                StockQuantity = 10,
                CategoryId = category.Id,
                Category = category,
                Images = new List<ProductImage>
                {
                    new ProductImage
                    {
                        Id = Guid.NewGuid(),
                        ProductId = productId,
                        ImageUrl = "/images/test.jpg",
                        IsMain = true
                    }
                }
            };
            
            _mockProductRepository.Setup(repo => repo.GetProductWithDetailsAsync(productId))
                .ReturnsAsync(product);
                
            // Act
            var result = await _productService.GetProductByIdAsync(productId);
            
            // Assert
            Assert.NotNull(result);
            Assert.Equal(productId, result.Id);
            Assert.Equal("Test Product", result.Name);
            Assert.Equal("Test Description", result.Description);
            Assert.Equal(99.99m, result.Price);
            Assert.Equal(10, result.StockQuantity);
            Assert.Equal(category.Id, result.CategoryId);
            Assert.Equal("Test Category", result.CategoryName);
            Assert.Equal("/images/test.jpg", result.MainImageUrl);
        }
        
        [Fact]
        public async Task GetProductsAsync_ShouldReturnPaginatedProducts()
        {
            // Arrange
            var products = new List<Product>
            {
                new Product
                {
                    Id = Guid.NewGuid(),
                    Name = "Product 1",
                    Price = 10.99m,
                    Category = new Category { Name = "Category 1" },
                    Images = new List<ProductImage>()
                },
                new Product
                {
                    Id = Guid.NewGuid(),
                    Name = "Product 2",
                    Price = 20.99m,
                    Category = new Category { Name = "Category 2" },
                    Images = new List<ProductImage>()
                }
            };
            
            _mockProductRepository.Setup(repo => repo.SearchProductsAsync(
                    null, null, null, null, 1, 10))
                .ReturnsAsync(products);
                
            _mockProductRepository.Setup(repo => repo.CountAsync(It.IsAny<System.Linq.Expressions.Expression<Func<Product, bool>>>()))
                .ReturnsAsync(2);
                
            // Act
            var result = await _productService.GetProductsAsync(1, 10);
            
            // Assert
            Assert.NotNull(result);
            Assert.Equal(2, result.Items.Count);
            Assert.Equal(1, result.PageIndex);
            Assert.Equal(10, result.PageSize);
            Assert.Equal(2, result.TotalCount);
            Assert.Equal(1, result.TotalPages);
            Assert.False(result.HasPreviousPage);
            Assert.False(result.HasNextPage);
        }
        
        [Fact]
        public async Task SearchProductsAsync_ShouldReturnFilteredProducts()
        {
            // Arrange
            var searchDto = new SearchDto
            {
                SearchTerm = "test",
                CategoryId = Guid.NewGuid(),
                MinPrice = 10,
                MaxPrice = 100,
                Page = 1,
                PageSize = 10
            };
            
            var products = new List<Product>
            {
                new Product
                {
                    Id = Guid.NewGuid(),
                    Name = "Test Product",
                    Price = 50.99m,
                    Category = new Category { Name = "Category" },
                    Images = new List<ProductImage>()
                }
            };
            
            _mockProductRepository.Setup(repo => repo.SearchProductsAsync(
                    searchDto.SearchTerm, searchDto.CategoryId, searchDto.MinPrice, searchDto.MaxPrice, searchDto.Page, searchDto.PageSize))
                .ReturnsAsync(products);
                
            _mockProductRepository.Setup(repo => repo.CountSearchResultsAsync(
                    searchDto.SearchTerm, searchDto.CategoryId, searchDto.MinPrice, searchDto.MaxPrice))
                .ReturnsAsync(1);
                
            // Act
            var result = await _productService.SearchProductsAsync(searchDto);
            
            // Assert
            Assert.NotNull(result);
            Assert.Single(result.Items);
            Assert.Equal("Test Product", result.Items[0].Name);
            Assert.Equal(50.99m, result.Items[0].Price);
        }
    }
}

// Add more test classes for other services and controllers
```

## Conclusion

In this section, we've implemented the backend of our online store application using .NET Web API. We've followed clean architecture principles with a layered approach:

1. **Core Layer**: Contains domain models, interfaces, and DTOs
2. **Infrastructure Layer**: Implements data access and services
3. **API Layer**: Exposes RESTful endpoints for client applications

The backend implementation includes:

- Entity Framework Core with PostgreSQL for data access
- Repository pattern for data abstraction
- Service layer for business logic
- JWT authentication for security
- Role-based authorization for access control
- API controllers for all required functionality
- Unit tests for key components

The API supports all the required functionality for our three user roles:
- **User**: Can search products, add to cart, and place orders
- **Manager**: Can manage products, update order status, and view statistics
- **Admin**: Can do everything a manager does, plus manage users

In the next section, we'll implement the authentication and authorization system to secure our API endpoints and manage user roles.
